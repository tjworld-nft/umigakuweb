<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dæµ·æ´‹è¿·è·¯ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #001122;
            font-family: Arial, sans-serif;
            color: white;
        }
        
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ffff;
        }
        
        .start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #00ffff;
            color: black;
            padding: 20px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            z-index: 200;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ffff;
        }
    </style>
</head>
<body>
    <div class="hud">
        <div>ğŸŒŠ æµ·å­¦ã®è¿·å®®</div>
        <div>ç« : <span id="currentLevel">1</span> / <span id="maxLevel">10</span></div>
        <div>â¤ï¸ HP: <span id="playerHP">100</span> / <span id="maxHP">100</span></div>
        <div>âš”ï¸ æ”»æ’ƒ: <span id="attackMode">å‰£</span></div>
        <div>æ™‚é–“: <span id="timer">0</span>ç§’</div>
        <div>åº§æ¨™: (<span id="posX">0</span>, <span id="posY">0</span>)</div>
    </div>
    
    <div class="controls">
        <div>ğŸ–±ï¸ ãƒã‚¦ã‚¹: è¦–ç‚¹ç§»å‹•</div>
        <div>âŒ¨ï¸ WASD: ç§»å‹•</div>
        <div>âš”ï¸ ã‚¹ãƒšãƒ¼ã‚¹: æ”»æ’ƒ</div>
        <div>ğŸ”„ ã‚·ãƒ•ãƒˆ: å‰£/é­”æ³•åˆ‡æ›¿</div>
        <div>ğŸ¯ ã‚´ãƒ¼ãƒ«: èµ¤ã„ã‚­ãƒ¥ãƒ¼ãƒ–</div>
    </div>
    
    <button class="start-button" id="startButton">ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚²ãƒ¼ãƒ é–‹å§‹</button>
    
    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.skypack.dev/gsap@3.12.2"></script>
    <script>
        class SimpleMaze3D {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.mazeSize = 11;
                this.cellSize = 4;
                this.wallHeight = 4;
                
                this.maze = [];
                this.startTime = null;
                this.gameStarted = false;
                this.pointerLocked = false;
                
                this.keys = {};
                this.moveSpeed = 0.1;
                
                // ãƒã‚¦ã‚¹åˆ¶å¾¡
                this.mouseX = 0;
                this.mouseY = 0;
                this.rotationX = 0;
                this.rotationY = 0;
                
                // ãƒ¬ãƒ™ãƒ«ã‚·ã‚¹ãƒ†ãƒ 
                this.currentLevel = 1;
                this.maxLevel = 10;
                this.levelCompleted = false;
                
                // ã‚¹ãƒˆãƒ¼ãƒªãƒ¼è¦ç´ 
                this.storyMessages = this.initStoryMessages();
                
                // Player
                this.player = {
                    hp: 100,
                    maxHP: 100,
                    damageFlashTime: 0,
                    takeDamage: (damage) => {
                        if (Date.now() - this.player.damageFlashTime > 1000) {
                            this.player.hp = Math.max(0, this.player.hp - damage);
                            this.player.damageFlashTime = Date.now();
                            this.showDamageFlash();
                            if (this.player.hp <= 0) this.gameOver();
                        }
                    }
                };
                
                // Sword
                this.swordMesh = null;
                this.swordAttackCooldown = 0;
                this.swordAttacking = false;
                
                // Enemies
                this.enemies = [];
                this.enemyManager = new EnemyManager(this);
                
                this.init();
            }
            
            initStoryMessages() {
                return {
                    1: {
                        title: "ç¬¬1ç« ï¼šç›®è¦šã‚",
                        intro: "æ°—ãŒã¤ãã¨ã€å›ã¯è¦‹çŸ¥ã‚‰ã¬é’ã„è¿·è·¯ã«å›šã‚ã‚Œã¦ã„ãŸ...\næ‰‹ã«ã¯å¤ã„å‰£ãŒæ¡ã‚‰ã‚Œã¦ã„ã‚‹ã€‚ãã—ã¦ã€ä¸æ€è­°ãªåŠ›ã‚’æ„Ÿã˜ã‚‹...\n\nâš”ï¸ ã‚¹ãƒšãƒ¼ã‚¹: æ”»æ’ƒ ğŸ”„ ã‚·ãƒ•ãƒˆ: å‰£/é­”æ³•åˆ‡æ›¿\nâ¤ï¸ HP: 100",
                        complete: "å°ã•ãªæµ·ç£ãŸã¡ã‚’é€€ã‘ã€æœ€åˆã®æ‰‰ãŒé–‹ã„ãŸ...\nã ãŒã€ã“ã‚Œã¯å§‹ã¾ã‚Šã«éããªã„ã€‚",
                        enemies: ["ã‚·ãƒ¼ã‚¢ãƒãƒ¢ãƒ", "å°ã•ãªã‚¯ãƒ©ã‚²"]
                    },
                    2: {
                        title: "ç¬¬2ç« ï¼šæ·±æµ·ã®å…¥ã‚Šå£", 
                        intro: "è¿·è·¯ã¯å¾ã€…ã«è¤‡é›‘ã«ãªã‚Šã€ã‚ˆã‚Šå±é™ºãªç”Ÿç‰©ãŒç¾ã‚Œå§‹ã‚ãŸã€‚\næ·±æµ·ã®è¬ãŒå›ã‚’å¾…ã¡å—ã‘ã¦ã„ã‚‹ã€‚\n\næµ·æµã«æ°—ã‚’ã¤ã‘ã‚...æ•µã¯å›ã‚’å–ã‚Šå›²ã‚‚ã†ã¨ã—ã¦ã„ã‚‹ã€‚",
                        complete: "æµ·æµã®éŸ³ãŒèã“ãˆã¦ããŸ...æ›´ãªã‚‹æ·±ã¿ã¸ã€‚\nå›ã®å‰£æŠ€ãŒç£¨ã‹ã‚Œã¦ãã¦ã„ã‚‹ã€‚",
                        enemies: ["é›»æ°—ã‚¦ãƒŠã‚®", "æ¯’ã‚¯ãƒ©ã‚²", "å°ã‚µãƒ¡"]
                    },
                    3: {
                        title: "ç¬¬3ç« ï¼šæ½®ã®æµã‚Œ",
                        intro: "æ½®ã®æµã‚ŒãŒè¿·è·¯ã‚’è¤‡é›‘ã«ã—ã€æ•µã‚‚å·§å¦™ã«ãªã£ã¦ããŸã€‚\nå†·é™ã•ã‚’ä¿ã¡ã€æˆ¦ç•¥çš„ã«æˆ¦ãŠã†ã€‚\n\nè¤‡æ•°ã®æ•µãŒåŒæ™‚ã«è¥²ã„ã‹ã‹ã£ã¦ãã‚‹...",
                        complete: "æ½®æµã‚’èª­ã¿ã€æ•µã®å‹•ãã‚’äºˆæ¸¬ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚\nå›ã¯ç¢ºå®Ÿã«æˆé•·ã—ã¦ã„ã‚‹ã€‚",
                        enemies: ["å·¨å¤§ãƒ’ãƒˆãƒ‡", "ç¾¤ã‚Œã‚µãƒ¡", "æ·±æµ·ã‚¤ã‚«"]
                    },
                    4: {
                        title: "ç¬¬4ç« ï¼šæ·±æµ·ã®å£°",
                        intro: "æ·±æµ·ã‹ã‚‰è¬ã‚ã„ãŸå£°ãŒèã“ãˆã‚‹ã€‚\nãã‚Œã¯å›ã‚’å°ãã®ã‹ã€æƒ‘ã‚ã™ã®ã‹ï¼Ÿ\n\nå£°ã«æƒ‘ã‚ã•ã‚Œã¦ã¯ã„ã‘ãªã„...çœŸã®æ•µã‚’è¦‹æ¥µã‚ã‚ã€‚",
                        complete: "å£°ã®æ­£ä½“ã«è¿‘ã¥ã„ã¦ã„ã‚‹...ãã—ã¦çœŸã®æˆ¦ã„ãŒå§‹ã¾ã£ãŸã€‚\nå›ã®å¿ƒã¯æºã‚‹ãŒãªã„ã€‚",
                        enemies: ["å¹½éœŠã‚¯ãƒ©ã‚²", "æ·±æµ·ã®ç•ªäºº", "éŸ³æ³¢ã‚µãƒ¡"]
                    },
                    5: {
                        title: "ç¬¬5ç« ï¼šæµ·åº•ç¥æ®¿",
                        intro: "å¤ã„æµ·åº•ç¥æ®¿ã®éºè·¡ã«è¾¿ã‚Šç€ã„ãŸã€‚\nç¥ç§˜çš„ãªåŠ›ãŒè¿·è·¯ã‚’å®ˆè­·ã—ã€å¤ä»£ã®å®ˆè­·ç£ãŒå¾©æ´»ã—ãŸã€‚\n\nç¥æ®¿ã®å®ˆè­·è€…ãŸã¡ã¯å®¹èµ¦ãªã„...",
                        complete: "ç¥æ®¿ã®ç§˜å¯†ã®ä¸€éƒ¨ã‚’è§£ãæ˜ã‹ã—ãŸã€‚\nã—ã‹ã—çœŸã®è©¦ç·´ã¯ã“ã‚Œã‹ã‚‰ã ã€‚",
                        enemies: ["çŸ³ã®å®ˆè­·è€…", "å¤ä»£ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³", "ç¥æ®¿ã®ç•ªå…µ"]
                    },
                    6: {
                        title: "ç¬¬6ç« ï¼šæµ·ç‹ã®è©¦ç·´",
                        intro: "æµ·ç‹ã‹ã‚‰ã®è©¦ç·´ãŒå§‹ã¾ã£ãŸã€‚\nã“ã‚Œã¾ã§ã®çµŒé¨“ãŒè©¦ã•ã‚Œã‚‹æ™‚ã ã€‚\n\næµ·ç‹ã®çœ·å±ãŸã¡ãŒå›ã‚’å¾…ã¡å—ã‘ã¦ã„ã‚‹...",
                        complete: "æµ·ç‹ã«èªã‚ã‚‰ã‚Œã¤ã¤ã‚ã‚‹...ã ãŒæœ€çµ‚è©¦ç·´ã¯ã¾ã å…ˆã ã€‚\nå›ã®åŠ›ã¯æµ·ç‹ãƒ¬ãƒ™ãƒ«ã«è¿‘ã¥ã„ã¦ã„ã‚‹ã€‚",
                        enemies: ["æµ·ç‹ã®é¨å£«", "ãƒªãƒ´ã‚¡ã‚¤ã‚¢ã‚µãƒ³", "ãƒˆãƒ©ã‚¤ãƒ‡ãƒ³ãƒˆãƒ»ã‚¬ãƒ¼ãƒ‰"]
                    },
                    7: {
                        title: "ç¬¬7ç« ï¼šåµã®è¿·å®®",
                        intro: "åµã®æµ·ã«æµ®ã‹ã¶è¿·å®®ã€‚\næ¿€æµã¨é›·é³´ã€ãã—ã¦åµã®ç²¾éœŠãŸã¡ãŒå›ã®è¡Œãæ‰‹ã‚’é˜»ã‚€ã€‚\n\né›·ã«æ‰“ãŸã‚Œã¬ã‚ˆã†æ³¨æ„ã—ã‚...æ•µã‚‚é›»æ’ƒã‚’æ”¾ã¤ã€‚",
                        complete: "åµã‚’ä¹—ã‚Šè¶Šãˆã€é›·ã®ç²¾éœŠãŸã¡ã‚’é®ã‚ãŸï¼\nå›ã®æ„å¿—ã¯åµã‚ˆã‚Šã‚‚å¼·ã„ã€‚",
                        enemies: ["é›·ã®ç²¾éœŠ", "åµã‚µãƒ¡", "é›»æ’ƒã‚¨ã‚¤"]
                    },
                    8: {
                        title: "ç¬¬8ç« ï¼šæ·±æ·µã®å¢ƒç•Œ",
                        intro: "å…‰ã‚‚å±Šã‹ã¬æ·±æ·µã®å¢ƒç•Œç·šã€‚\nã“ã“ã‹ã‚‰å…ˆã¯çœŸã®å‹‡è€…ã®ã¿ãŒé€²ã‚ã‚‹ã€‚\n\né—‡ã®æ€ªç‰©ãŸã¡ãŒæ½œã‚“ã§ã„ã‚‹...å…‰ã‚’å¤±ã†ãªã€‚",
                        complete: "æ·±æ·µã‚’è¶ŠãˆãŸè€…ã‚ˆ...å›ã¯é¸ã°ã‚Œã—è€…ãªã®ã‹ï¼Ÿ\né—‡ã®åŠ›ã™ã‚‰å›ã®ã‚‚ã®ã¨ãªã£ãŸã€‚",
                        enemies: ["æ·±æ·µã®é­”ç‰©", "é—‡ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³", "è™šç„¡ã‚µãƒ¡"]
                    },
                    9: {
                        title: "ç¬¬9ç« ï¼šæœ€å¾Œã®å®ˆè­·è€…",
                        intro: "æœ€å¾Œã®å®ˆè­·è€…ãŒç«‹ã¡ã¯ã ã‹ã‚‹ã€‚\nå…¨ã¦ã®çŸ¥è­˜ã¨å‹‡æ°—ã‚’çµé›†ã›ã‚ˆã€‚\n\nä¼èª¬ã®æµ·ç£ãŸã¡ã¨ã®æœ€çµ‚æ±ºæˆ¦ãŒå§‹ã¾ã‚‹...",
                        complete: "å®ˆè­·è€…ã‚’è¶ŠãˆãŸ...ã¤ã„ã«æœ€çµ‚ã®æ‰‰ãŒè¦‹ãˆã¦ããŸã€‚\nå›ã¯ä¼èª¬ã®æˆ¦å£«ã¨ãªã£ãŸã€‚",
                        enemies: ["æœ€çµ‚å®ˆè­·è€…", "æµ·ã®é¾ç‹", "ã‚¢ãƒ“ã‚¹ãƒ»ãƒªãƒ´ã‚¡ã‚¤ã‚¢ã‚µãƒ³"]
                    },
                    10: {
                        title: "ç¬¬10ç« ï¼šæµ·å­¦ã®çœŸç†",
                        intro: "ã¤ã„ã«æœ€çµ‚å±¤ã«åˆ°é”ã—ãŸã€‚\næµ·å­¦ã®çœŸç†ãŒã“ã“ã«çœ ã£ã¦ã„ã‚‹ã€‚\n\næœ€å¾Œã®æ•µã¯...å›è‡ªèº«ã®ææ€–ã ã€‚ãã‚Œã‚’ä¹—ã‚Šè¶Šãˆã‚ã€‚",
                        complete: "ãŠã‚ã§ã¨ã†ï¼å›ã¯çœŸã®æµ·å­¦ãƒã‚¹ã‚¿ãƒ¼ã¨ãªã£ãŸï¼\næ·±æµ·ã®å…¨ã¦ã®ç§˜å¯†ã‚’è§£ãæ˜ã‹ã—ã€ã™ã¹ã¦ã®æ•µã‚’æ‰“ã¡å€’ã—ã€\nçœŸã®å‹‡è€…ã¨ã—ã¦ä¼èª¬ã¨ãªã£ãŸã®ã ã€‚",
                        enemies: ["æµ·å­¦ã®åŒ–èº«", "æ·±æµ·çš‡å¸", "çœŸç†ã®ç•ªäºº"]
                    }
                };
            }
            
            init() {
                console.log('Initializing game...');
                this.setupScene();
                this.generateComplexMaze();
                this.createMaze3D();
                this.setupEventListeners();
                this.animate();
                
                console.log('Game initialized');
            }
            
            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x001a33); // ã‚ˆã‚Šæ·±ã„æµ·ã®è‰²
                this.scene.fog = new THREE.Fog(0x001a33, 5, 25); // æµ·ä¸­ã®éœ§åŠ¹æœ
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(6, 2, 6); // è¿·è·¯å†…éƒ¨ã®ç¢ºå®Ÿã«é€šè·¯ã®ä½ç½®
                console.log('Camera start position:', this.camera.position);
                
                // Renderer
                const canvas = document.getElementById('canvas');
                this.renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                // æµ·ä¸­ã®ç…§æ˜
                const ambientLight = new THREE.AmbientLight(0x002244, 0.4); // é’ã£ã½ã„ç’°å¢ƒå…‰
                this.scene.add(ambientLight);
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ©ã‚¤ãƒˆï¼ˆæ½œæ°´ãƒ©ã‚¤ãƒˆé¢¨ï¼‰
                const playerLight = new THREE.SpotLight(0xffffff, 1, 20, Math.PI / 6, 0.3);
                playerLight.position.copy(this.camera.position);
                playerLight.target.position.set(0, 0, -1);
                this.scene.add(playerLight);
                this.scene.add(playerLight.target);
                this.playerLight = playerLight;
                
                // æµ·ä¸­ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœ
                this.createOceanParticles();
                
                console.log('Ocean scene setup complete');
            }
            
            createOceanParticles() {
                // æµ·ä¸­ã®æµ®éŠç‰©ï¼ˆãƒ—ãƒ©ãƒ³ã‚¯ãƒˆãƒ³ã€æ³¡ãªã©ï¼‰
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 100;     // x
                    positions[i + 1] = Math.random() * 20;          // y
                    positions[i + 2] = (Math.random() - 0.5) * 100; // z
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: 0x4499ff,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }
            
            generateComplexMaze() {
                // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸã‚µã‚¤ã‚ºã¨é›£æ˜“åº¦
                this.setLevelDifficulty();
                
                // ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ç´¹ä»‹ã‚’è¡¨ç¤º
                this.showStoryIntro();
                
                // è¿·è·¯ç”Ÿæˆ
                this.maze = [];
                
                // å…¨ã¦å£ã§åˆæœŸåŒ–
                for (let i = 0; i < this.mazeSize; i++) {
                    this.maze[i] = [];
                    for (let j = 0; j < this.mazeSize; j++) {
                        this.maze[i][j] = 1; // å£
                    }
                }
                
                // å†å¸°ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯æ³•ã§è¿·è·¯ç”Ÿæˆ
                this.visited = [];
                for (let i = 0; i < this.mazeSize; i++) {
                    this.visited[i] = [];
                    for (let j = 0; j < this.mazeSize; j++) {
                        this.visited[i][j] = false;
                    }
                }
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã‹ã‚‰è¿·è·¯ã‚’æ˜ã‚‹
                this.carveMaze(1, 1);
                
                // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸè¿½åŠ ã®è¤‡é›‘ã•
                this.addLevelComplexity();
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆã¨ã‚´ãƒ¼ãƒ«ã‚’ç¢ºå®Ÿã«é€šè·¯ã«ã™ã‚‹
                this.maze[1][1] = 0; // ã‚¹ã‚¿ãƒ¼ãƒˆ
                this.maze[this.mazeSize - 2][this.mazeSize - 2] = 0; // ã‚´ãƒ¼ãƒ«
                
                console.log(`Level ${this.currentLevel} maze generated (${this.mazeSize}x${this.mazeSize})`);
            }
            
            setLevelDifficulty() {
                // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ã‚µã‚¤ã‚ºã¨è¨­å®šã‚’å¤‰æ›´
                if (this.currentLevel <= 2) {
                    this.mazeSize = 11; // åˆç´š
                    this.moveSpeed = 0.12;
                } else if (this.currentLevel <= 4) {
                    this.mazeSize = 15; // ä¸­ç´š
                    this.moveSpeed = 0.10;
                } else if (this.currentLevel <= 6) {
                    this.mazeSize = 19; // ä¸Šç´š
                    this.moveSpeed = 0.08;
                } else if (this.currentLevel <= 8) {
                    this.mazeSize = 23; // è¶…ç´š
                    this.moveSpeed = 0.07;
                } else {
                    this.mazeSize = 27; // ç¥ç´š
                    this.moveSpeed = 0.06;
                }
            }
            
            addLevelComplexity() {
                // ãƒ¬ãƒ™ãƒ«ãŒé«˜ã„ã»ã©è¤‡é›‘ãªä»•æ›ã‘ã‚’è¿½åŠ 
                if (this.currentLevel >= 3) {
                    // ãƒ‡ãƒƒãƒ‰ã‚¨ãƒ³ãƒ‰ã‚’å¢—ã‚„ã™
                    this.addDeadEnds();
                }
                
                if (this.currentLevel >= 5) {
                    // ãƒ«ãƒ¼ãƒ—ã‚’ä½œã£ã¦æ··ä¹±ã•ã›ã‚‹
                    this.addLoops();
                }
                
                if (this.currentLevel >= 7) {
                    // å½ã®ã‚´ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ã‚’è¿½åŠ 
                    this.addFakeGoalAreas();
                }
            }
            
            addDeadEnds() {
                const deadEndCount = Math.floor(this.currentLevel * 1.5);
                for (let i = 0; i < deadEndCount; i++) {
                    const x = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    const y = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    if (this.maze[y][x] === 0) {
                        // ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘ã«çŸ­ã„è¡Œãæ­¢ã¾ã‚Šã‚’ä½œã‚‹
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        const dir = directions[Math.floor(Math.random() * directions.length)];
                        const newX = x + dir[0] * 2;
                        const newY = y + dir[1] * 2;
                        if (newX > 0 && newX < this.mazeSize - 1 && newY > 0 && newY < this.mazeSize - 1) {
                            this.maze[y + dir[1]][x + dir[0]] = 0;
                            this.maze[newY][newX] = 0;
                        }
                    }
                }
            }
            
            addLoops() {
                const loopCount = Math.floor(this.currentLevel * 0.8);
                for (let i = 0; i < loopCount; i++) {
                    const x = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    const y = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    if (this.maze[y][x] === 1) {
                        // éš£æ¥ã™ã‚‹é€šè·¯ãŒ2ã¤ä»¥ä¸Šã‚ã‚Œã°å£ã‚’å‰Šé™¤ã—ã¦ãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚‹
                        let adjacentPaths = 0;
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        for (const [dx, dy] of directions) {
                            if (this.maze[y + dy] && this.maze[y + dy][x + dx] === 0) {
                                adjacentPaths++;
                            }
                        }
                        if (adjacentPaths >= 2) {
                            this.maze[y][x] = 0;
                        }
                    }
                }
            }
            
            addFakeGoalAreas() {
                // å½ã®ã‚´ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ã‚’æ•°ç®‡æ‰€ã«é…ç½®
                const fakeGoals = Math.min(3, Math.floor(this.currentLevel * 0.5));
                for (let i = 0; i < fakeGoals; i++) {
                    const x = Math.floor(Math.random() * (this.mazeSize - 6)) + 3;
                    const y = Math.floor(Math.random() * (this.mazeSize - 6)) + 3;
                    // 3x3ã®å°ã•ãªã‚¨ãƒªã‚¢ã‚’ä½œã‚‹
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (x + dx > 0 && x + dx < this.mazeSize - 1 && 
                                y + dy > 0 && y + dy < this.mazeSize - 1) {
                                this.maze[y + dy][x + dx] = 0;
                            }
                        }
                    }
                }
            }
            
            carveMaze(x, y) {
                this.visited[y][x] = true;
                this.maze[y][x] = 0; // é€šè·¯ã«ã™ã‚‹
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘é †åº
                const directions = [
                    [0, -2], [2, 0], [0, 2], [-2, 0] // ä¸Šã€å³ã€ä¸‹ã€å·¦
                ].sort(() => Math.random() - 0.5);
                
                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    // å¢ƒç•Œå†…ã‹ã¤æœªè¨ªå•ã®å ´åˆ
                    if (newX > 0 && newX < this.mazeSize - 1 && 
                        newY > 0 && newY < this.mazeSize - 1 && 
                        !this.visited[newY][newX]) {
                        
                        // é–“ã®å£ã‚’å‰Šé™¤
                        this.maze[y + dy/2][x + dx/2] = 0;
                        this.carveMaze(newX, newY);
                    }
                }
            }
            
            createMaze3D() {
                const CELL = this.cellSize;
                const wallHeight = this.wallHeight;
                
                // å£ç·šã®ãƒãƒ†ãƒªã‚¢ãƒ«
                const wallMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
                
                // å„ã‚»ãƒ«ã®å£ç·šã‚’ç”Ÿæˆ
                for (let cz = 0; cz < this.mazeSize; cz++) {
                    for (let cx = 0; cx < this.mazeSize; cx++) {
                        if (this.maze[cz][cx] === 1) {
                            // ã‚»ãƒ« (cx, cz) ãŒå£ã®å ´åˆã€å„è¾ºã«ç·šã‚’æç”»
                            this.createWallLines(cx, cz, CELL, wallHeight, wallMaterial);
                        }
                    }
                }
                
                // ã‚´ãƒ¼ãƒ«ã‚’ä½œæˆï¼ˆãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
                this.createGoal();
                
                // å‰£ã‚’ä½œæˆ
                this.createSword();
                
                // æ•µã‚’é…ç½®
                this.spawnEnemies();
                
                console.log('3D maze created with wall lines, sword, and enemies');
            }
            
            createWallLines(cx, cz, CELL, wallHeight, material) {
                const x = cx * CELL;
                const z = cz * CELL;
                
                // åŒ—å£ (zå´)
                this.addWallLine(
                    [x, 0, z, (x + CELL), 0, z, x, wallHeight, z, (x + CELL), wallHeight, z],
                    material
                );
                
                // æ±å£ (x+1å´)  
                this.addWallLine(
                    [(x + CELL), 0, z, (x + CELL), 0, (z + CELL), (x + CELL), wallHeight, z, (x + CELL), wallHeight, (z + CELL)],
                    material
                );
                
                // å—å£ (z+1å´)
                this.addWallLine(
                    [x, 0, (z + CELL), (x + CELL), 0, (z + CELL), x, wallHeight, (z + CELL), (x + CELL), wallHeight, (z + CELL)],
                    material
                );
                
                // è¥¿å£ (xå´)
                this.addWallLine(
                    [x, 0, z, x, 0, (z + CELL), x, wallHeight, z, x, wallHeight, (z + CELL)],
                    material
                );
            }
            
            addWallLine(points, material) {
                const geometry = new THREE.BufferGeometry();
                const vertices = new Float32Array(points);
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                
                // ç·šã®æç”»é †åºï¼ˆåº•è¾ºâ†’ä¸Šè¾ºâ†’ç¸¦ç·šï¼‰
                const indices = [
                    0, 1,  // åº•è¾º
                    2, 3,  // ä¸Šè¾º
                    0, 2,  // å·¦ç¸¦ç·š
                    1, 3   // å³ç¸¦ç·š
                ];
                geometry.setIndex(indices);
                
                const line = new THREE.LineSegments(geometry, material);
                this.scene.add(line);
            }
            
            createGoal() {
                const goalGeometry = new THREE.BoxGeometry(2, 2, 2);
                const goalEdges = new THREE.EdgesGeometry(goalGeometry);
                const goalMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xff0000
                });
                
                this.goal = new THREE.LineSegments(goalEdges, goalMaterial);
                this.goal.position.set((this.mazeSize - 2) * this.cellSize, 1, (this.mazeSize - 2) * this.cellSize);
                this.scene.add(this.goal);
                
                // ã‚´ãƒ¼ãƒ«ã®å…‰ã‚‹åŠ¹æœ
                const goalLight = new THREE.PointLight(0xff0000, 1, 10);
                goalLight.position.copy(this.goal.position);
                this.scene.add(goalLight);
            }
            
            createSword() {
                // å‰£ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªï¼ˆç›®ç«‹ã¤å½¢çŠ¶ï¼‰
                const swordGroup = new THREE.Group();
                
                // åˆ€èº«ï¼ˆå¤§ããã€å…‰ã‚‹ã‚ˆã†ã«ï¼‰
                const bladeGeometry = new THREE.BoxGeometry(0.2, 0.1, 2.0);
                const bladeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9,
                    emissive: 0x444444
                });
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.z = 1.0;
                swordGroup.add(blade);
                
                // åˆ€èº«ã®ã‚¨ãƒƒã‚¸ï¼ˆãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
                const bladeEdges = new THREE.EdgesGeometry(bladeGeometry);
                const edgeMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x00ffff,
                    linewidth: 2
                });
                const bladeOutline = new THREE.LineSegments(bladeEdges, edgeMaterial);
                bladeOutline.position.z = 1.0;
                swordGroup.add(bladeOutline);
                
                // æŸ„ï¼ˆå¤§ããã€ç›®ç«‹ã¤è‰²ï¼‰
                const handleGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.4);
                const handleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x8B4513,
                    transparent: true,
                    opacity: 0.9
                });
                const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                handle.position.z = -0.2;
                swordGroup.add(handle);
                
                // æŸ„ã®ã‚¨ãƒƒã‚¸
                const handleEdges = new THREE.EdgesGeometry(handleGeometry);
                const handleOutline = new THREE.LineSegments(handleEdges, new THREE.LineBasicMaterial({ color: 0xffaa00 }));
                handleOutline.position.z = -0.2;
                swordGroup.add(handleOutline);
                
                // ã‚«ãƒ¡ãƒ©ã«è£…ç€ï¼ˆå³æ‰‹ä½ç½®ã€ã‚ˆã‚Šæ‰‹å‰ã«ï¼‰
                this.sword = swordGroup;
                this.sword.position.set(0.4, -0.3, -0.6);
                this.sword.rotation.y = Math.PI / 6;
                this.sword.rotation.x = -Math.PI / 12;
                this.camera.add(this.sword);
                
                console.log('å‰£ã‚’ä½œæˆã—ã¾ã—ãŸ:', this.sword);
            }
            
            spawnEnemies() {
                this.enemies = [];
                const enemyCount = Math.min(3 + this.currentLevel, 8); // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦æ•µã®æ•°ã‚’å¢—åŠ 
                
                for (let i = 0; i < enemyCount; i++) {
                    this.createEnemy();
                }
            }
            
            createEnemy() {
                // æ•µã®3Dãƒ¢ãƒ‡ãƒ«ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªæµ·ç£ï¼‰
                const enemyGroup = new THREE.Group();
                
                // ä½“ï¼ˆãƒ¡ã‚¤ãƒ³ï¼‰
                const bodyGeometry = new THREE.SphereGeometry(0.8, 8, 6);
                const bodyMaterial = new THREE.MeshBasicMaterial({ 
                    color: this.getEnemyColor(),
                    wireframe: true 
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                enemyGroup.add(body);
                
                // è§¦æ‰‹ã‚„é°­ï¼ˆè£…é£¾ï¼‰
                for (let i = 0; i < 4; i++) {
                    const tentacleGeometry = new THREE.CylinderGeometry(0.1, 0.05, 1);
                    const tentacleMaterial = new THREE.MeshBasicMaterial({ 
                        color: this.getEnemyColor(),
                        wireframe: true 
                    });
                    const tentacle = new THREE.Mesh(tentacleGeometry, tentacleMaterial);
                    tentacle.position.set(
                        Math.cos(i * Math.PI / 2) * 0.6,
                        -0.5,
                        Math.sin(i * Math.PI / 2) * 0.6
                    );
                    tentacle.rotation.z = Math.PI / 6;
                    enemyGroup.add(tentacle);
                }
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«é…ç½®ï¼ˆé€šè·¯ã®ã¿ï¼‰
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 50) {
                    const x = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    const z = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    
                    if (this.maze[z][x] === 0) { // é€šè·¯ã®å ´åˆ
                        enemyGroup.position.set(x * this.cellSize, 1, z * this.cellSize);
                        placed = true;
                    }
                    attempts++;
                }
                
                if (placed) {
                    // æ•µã®å±æ€§
                    enemyGroup.userData = {
                        hp: 20 + this.currentLevel * 5,
                        maxHP: 20 + this.currentLevel * 5,
                        damage: 10 + this.currentLevel * 2,
                        speed: 0.02 + this.currentLevel * 0.005,
                        lastAttackTime: 0,
                        attackCooldown: 2000, // 2ç§’
                        alive: true
                    };
                    
                    this.scene.add(enemyGroup);
                    this.enemies.push(enemyGroup);
                }
            }
            
            getEnemyColor() {
                const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            setupEventListeners() {
                const startButton = document.getElementById('startButton');
                const canvas = document.getElementById('canvas');
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
                startButton.addEventListener('click', () => {
                    console.log('Start button clicked');
                    this.startGame();
                });
                
                // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ
                document.addEventListener('keydown', (event) => {
                    console.log('Key pressed:', event.code);
                    this.keys[event.code] = true;
                    
                    // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§æ”»æ’ƒ
                    if (event.code === 'Space' && this.gameStarted) {
                        event.preventDefault(); // ãƒšãƒ¼ã‚¸ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã
                        this.performAttack();
                    }
                    
                    // ã‚·ãƒ•ãƒˆã‚­ãƒ¼ã§æ”»æ’ƒãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
                    if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
                        if (this.gameStarted) {
                            this.toggleAttackMode();
                        }
                    }
                });
                
                document.addEventListener('keyup', (event) => {
                    console.log('Key released:', event.code);
                    this.keys[event.code] = false;
                });
                
                // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
                canvas.addEventListener('click', () => {
                    if (!this.pointerLocked) {
                        canvas.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.pointerLocked = document.pointerLockElement === canvas;
                    console.log('Pointer lock changed:', this.pointerLocked);
                });
                
                document.addEventListener('mousemove', (event) => {
                    if (this.pointerLocked && this.gameStarted) {
                        const movementX = event.movementX || 0;
                        const movementY = event.movementY || 0;
                        
                        this.rotationY -= movementX * 0.002;
                        this.rotationX -= movementY * 0.002;
                        this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));
                        
                        // Eulerè§’ã§ã®å›è»¢è¨­å®š
                        const euler = new THREE.Euler(this.rotationX, this.rotationY, 0, 'YXZ');
                        this.camera.quaternion.setFromEuler(euler);
                        
                        console.log('Camera rotation:', { x: this.rotationX, y: this.rotationY });
                    }
                });
                
                // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚º
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                console.log('Event listeners setup complete');
            }
            
            startGame() {
                console.log('Starting game...');
                this.gameStarted = true;
                this.startTime = Date.now();
                
                const startButton = document.getElementById('startButton');
                startButton.style.display = 'none';
                
                const canvas = document.getElementById('canvas');
                canvas.requestPointerLock();
                
                console.log('Game started');
            }
            
            updateMovement() {
                if (!this.gameStarted) {
                    return;
                }
                
                // ã‚«ãƒ¡ãƒ©ã®å‘ã„ã¦ã„ã‚‹æ–¹å‘ã‚’å–å¾—
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                
                // å³æ–¹å‘ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(this.camera.quaternion);
                
                // Yæˆåˆ†ã‚’0ã«ã—ã¦æ°´å¹³ç§»å‹•ã®ã¿ã«ã™ã‚‹
                direction.y = 0;
                right.y = 0;
                direction.normalize();
                right.normalize();
                
                // ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                let dx = 0;
                let dz = 0;
                
                if (this.keys['KeyW']) {
                    dx += direction.x * this.moveSpeed;
                    dz += direction.z * this.moveSpeed;
                }
                if (this.keys['KeyS']) {
                    dx -= direction.x * this.moveSpeed;
                    dz -= direction.z * this.moveSpeed;
                }
                if (this.keys['KeyA']) {
                    dx -= right.x * this.moveSpeed;
                    dz -= right.z * this.moveSpeed;
                }
                if (this.keys['KeyD']) {
                    dx += right.x * this.moveSpeed;
                    dz += right.z * this.moveSpeed;
                }
                
                // ãƒ—ãƒ­ä»•æ§˜ã®è¡çªåˆ¤å®šä»˜ãç§»å‹•
                this.movePlayer(dx, dz, 1.0);
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ©ã‚¤ãƒˆã‚’è¿½å¾“ã•ã›ã‚‹
                this.playerLight.position.copy(this.camera.position);
                const lightDirection = new THREE.Vector3(0, 0, -1);
                lightDirection.applyQuaternion(this.camera.quaternion);
                this.playerLight.target.position.copy(this.camera.position).add(lightDirection.multiplyScalar(5));
                
                this.updateHUD();
            }
            
            movePlayer(dx, dz, delta) {
                const playerR = 0.3; // æ¨™æº–çš„ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŠå¾„ã«æˆ»ã™
                const CELL = this.cellSize;
                
                // ç¾åœ¨ä½ç½®
                const pos = this.camera.position;
                const currentPos = { x: pos.x, z: pos.z };
                
                // ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã®é•·ã•
                const moveLen = Math.sqrt(dx * dx + dz * dz);
                if (moveLen === 0) return;
                
                // æ®µéšçš„ç§»å‹•ï¼ˆå°ã•ãªã‚¹ãƒ†ãƒƒãƒ—ã§å®‰å…¨ã«ï¼‰
                const steps = Math.ceil(moveLen / 0.05); // 0.05å˜ä½ã§ç§»å‹•
                const stepX = dx / steps;
                const stepZ = dz / steps;
                
                for (let i = 0; i < steps; i++) {
                    const nextX = pos.x + stepX;
                    const nextZ = pos.z + stepZ;
                    const nextPos = { x: nextX, z: nextZ };
                    
                    // ç§»å‹•å…ˆãŒå®‰å…¨ã‹ãƒã‚§ãƒƒã‚¯
                    if (this.isSafePosition(nextPos, playerR, CELL)) {
                        pos.x = nextX;
                        pos.z = nextZ;
                    } else {
                        // ç§»å‹•ã§ããªã„å ´åˆã¯ã“ã“ã§åœæ­¢
                        break;
                    }
                }
            }
            
            isSafePosition(p, playerR, CELL) {
                // ã‚ˆã‚Šä¿å®ˆçš„ã§ç¢ºå®Ÿãªå®‰å…¨åˆ¤å®š
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å††å½¢ç¯„å›²ã‚’ç´°ã‹ããƒã‚§ãƒƒã‚¯
                const checkPoints = [];
                const numPoints = 12; // å††å‘¨ä¸Šã®12ç‚¹
                
                // ä¸­å¿ƒç‚¹
                checkPoints.push({ x: p.x, z: p.z });
                
                // å††å‘¨ä¸Šã®ç‚¹ã€…
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    checkPoints.push({
                        x: p.x + Math.cos(angle) * playerR,
                        z: p.z + Math.sin(angle) * playerR
                    });
                }
                
                // å„ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãŒå®‰å…¨ã‹ã©ã†ã‹
                for (const point of checkPoints) {
                    const cellX = Math.floor(point.x / CELL);
                    const cellZ = Math.floor(point.z / CELL);
                    
                    // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
                    if (cellX < 0 || cellX >= this.mazeSize || cellZ < 0 || cellZ >= this.mazeSize) {
                        return false;
                    }
                    
                    // å£ãƒã‚§ãƒƒã‚¯
                    if (this.maze[cellZ][cellX] === 1) {
                        return false;
                    }
                }
                
                return true;
            }
            
            isBlocked(p, playerR, CELL) {
                return !this.isSafePosition(p, playerR, CELL);
            }
            
            
            updateHUD() {
                const gridX = Math.floor(this.camera.position.x / this.cellSize);
                const gridZ = Math.floor(this.camera.position.z / this.cellSize);
                
                document.getElementById('currentLevel').textContent = this.currentLevel;
                document.getElementById('maxLevel').textContent = this.maxLevel;
                document.getElementById('playerHP').textContent = this.playerHP;
                document.getElementById('maxHP').textContent = this.maxHP;
                document.getElementById('attackMode').textContent = this.attackMode === 'sword' ? 'å‰£' : 'é­”æ³•';
                document.getElementById('posX').textContent = gridX;
                document.getElementById('posY').textContent = gridZ;
                
                // HPãƒãƒ¼ã®è‰²å¤‰æ›´
                const hpElement = document.getElementById('playerHP');
                if (this.playerHP < this.maxHP * 0.3) {
                    hpElement.style.color = '#ff4444';
                } else if (this.playerHP < this.maxHP * 0.6) {
                    hpElement.style.color = '#ffaa44';
                } else {
                    hpElement.style.color = '#ffffff';
                }
                
                // ã‚´ãƒ¼ãƒ«åˆ¤å®š
                if (this.goal) {
                    const distance = this.camera.position.distanceTo(this.goal.position);
                    if (distance < 3) {
                        this.gameWin();
                    }
                }
            }
            
            toggleAttackMode() {
                this.attackMode = this.attackMode === 'sword' ? 'magic' : 'sword';
                document.getElementById('attackMode').textContent = this.attackMode === 'sword' ? 'å‰£' : 'é­”æ³•';
                console.log(`æ”»æ’ƒãƒ¢ãƒ¼ãƒ‰: ${this.attackMode}`);
            }

            performAttack() {
                const currentTime = Date.now();
                if (currentTime - this.attackCooldown < 500) return; // æ”»æ’ƒã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
                
                this.attackCooldown = currentTime;
                this.isAttacking = true;
                
                if (this.attackMode === 'sword') {
                    this.performSwordAttack();
                } else {
                    this.performMagicAttack();
                }
            }
            
            performSwordAttack() {
                // å‰£ã®æ¿€ã—ã„æ”»æ’ƒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.sword) {
                    // æ”»æ’ƒè»Œé“ã‚’æãå‰£ã®å‹•ã
                    this.createSwordTrail();
                    
                    // ç¬¬1ãƒ•ã‚§ãƒ¼ã‚º: å¤§ããæŒ¯ã‚Šä¸Šã’ï¼ˆæº–å‚™å‹•ä½œï¼‰
                    this.animateSwordPhase({
                        rotation: { x: Math.PI / 2, y: Math.PI / 4, z: -Math.PI / 4 },
                        position: { x: 0.8, y: 0.3, z: -0.3 },
                        scale: { x: 1.2, y: 1.2, z: 1.2 }
                    });
                    
                    setTimeout(() => {
                        if (this.sword) {
                            // ç¬¬2ãƒ•ã‚§ãƒ¼ã‚º: æ¿€ã—ã„æŒ¯ã‚Šä¸‹ã‚ã—ï¼ˆæœ€å¤§é€Ÿåº¦ï¼‰
                            this.animateSwordPhase({
                                rotation: { x: -Math.PI / 2, y: -Math.PI / 6, z: Math.PI / 6 },
                                position: { x: 0.0, y: -0.8, z: -1.5 },
                                scale: { x: 1.5, y: 1.5, z: 1.5 }
                            });
                            
                            // æ”»æ’ƒæ™‚ã®çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                            this.createSwordStrike();
                            
                            // ã‚«ãƒ¡ãƒ©ã®æºã‚ŒåŠ¹æœ
                            this.createCameraShake();
                        }
                    }, 80);
                    
                    setTimeout(() => {
                        if (this.sword) {
                            // ç¬¬3ãƒ•ã‚§ãƒ¼ã‚º: ãƒ•ã‚©ãƒ­ãƒ¼ã‚¹ãƒ«ãƒ¼
                            this.animateSwordPhase({
                                rotation: { x: -Math.PI / 3, y: 0, z: 0 },
                                position: { x: 0.2, y: -0.6, z: -1.2 },
                                scale: { x: 1.2, y: 1.2, z: 1.2 }
                            });
                        }
                    }, 160);
                    
                    setTimeout(() => {
                        if (this.sword) {
                            // ç¬¬4ãƒ•ã‚§ãƒ¼ã‚º: å…ƒã®ä½ç½®ã«æˆ»ã‚‹
                            this.animateSwordPhase({
                                rotation: { x: -Math.PI / 12, y: Math.PI / 6, z: 0 },
                                position: { x: 0.4, y: -0.3, z: -0.6 },
                                scale: { x: 1, y: 1, z: 1 }
                            });
                        }
                        this.isAttacking = false;
                    }, 300);
                }
                
                // å‰£æ”»æ’ƒã®ç¯„å›²åˆ¤å®š
                const attackRange = 3;
                const playerPos = this.camera.position;
                
                // ã‚«ãƒ¡ãƒ©ã®å‘ã„ã¦ã„ã‚‹æ–¹å‘ã‚’å–å¾—
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                
                for (const enemy of this.enemies) {
                    if (!enemy.userData.alive) continue;
                    
                    const distance = playerPos.distanceTo(enemy.position);
                    
                    // è·é›¢ã¨æ–¹å‘ã®ä¸¡æ–¹ã‚’ãƒã‚§ãƒƒã‚¯
                    if (distance <= attackRange) {
                        const enemyDirection = new THREE.Vector3()
                            .subVectors(enemy.position, playerPos)
                            .normalize();
                        
                        const angle = direction.angleTo(enemyDirection);
                        
                        // å‰æ–¹45åº¦ä»¥å†…ã®æ•µã‚’æ”»æ’ƒ
                        if (angle < Math.PI / 4) {
                            const damage = 30 + Math.floor(Math.random() * 20);
                            this.damageEnemy(enemy, damage, 'sword');
                        }
                    }
                }
            }
            
            performMagicAttack() {
                // é­”æ³•å¼¾ã‚’ç™ºå°„
                const playerPos = this.camera.position.clone();
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                
                const projectile = this.createMagicProjectile(playerPos, direction);
                this.magicProjectiles.push(projectile);
                this.scene.add(projectile);
                
                this.isAttacking = false;
            }
            
            createMagicProjectile(startPos, direction) {
                // é­”æ³•å¼¾ã®è¦‹ãŸç›®
                const geometry = new THREE.SphereGeometry(0.2, 8, 6);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                const projectile = new THREE.Mesh(geometry, material);
                
                // å…‰ã‚‹åŠ¹æœ
                const glowGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x44ffff,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                projectile.add(glow);
                
                projectile.position.copy(startPos);
                projectile.userData = {
                    direction: direction.clone(),
                    speed: 0.5,
                    damage: 20 + Math.floor(Math.random() * 15),
                    life: 100 // ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
                };
                
                return projectile;
            }
            
            animateSwordPhase(params) {
                // å‰£ã®ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.sword) {
                    this.sword.rotation.x = params.rotation.x;
                    this.sword.rotation.y = params.rotation.y;
                    this.sword.rotation.z = params.rotation.z;
                    this.sword.position.set(params.position.x, params.position.y, params.position.z);
                    this.sword.scale.set(params.scale.x, params.scale.y, params.scale.z);
                }
            }
            
            createSwordStrike() {
                // å‰£ã®æ”»æ’ƒæ™‚ã®è¿·åŠ›çš„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                const strikeGeometry = new THREE.RingGeometry(0.5, 2, 8);
                const strikeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                
                const strike = new THREE.Mesh(strikeGeometry, strikeMaterial);
                strike.position.set(0.1, -0.5, -1.2);
                strike.rotation.x = Math.PI / 2;
                this.camera.add(strike);
                
                // æ¿€ã—ã„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                let scale = 0.5;
                let opacity = 0.8;
                const animateStrike = () => {
                    scale += 0.2;
                    opacity -= 0.1;
                    
                    if (strike.material && strike.scale) {
                        strike.scale.setScalar(scale);
                        strike.material.opacity = opacity;
                    }
                    
                    if (opacity <= 0) {
                        this.camera.remove(strike);
                    } else {
                        setTimeout(animateStrike, 30);
                    }
                };
                
                setTimeout(animateStrike, 50);
            }
            
            createSwordTrail() {
                // å‰£ã®è»Œè·¡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆæ”¹è‰¯ç‰ˆï¼‰
                const trailPoints = [
                    new THREE.Vector3(0.5, 0, -0.5),     // é–‹å§‹ç‚¹
                    new THREE.Vector3(0.3, -0.2, -0.8),  // ä¸­é–“ç‚¹
                    new THREE.Vector3(0.1, -0.5, -1.2),  // çµ‚äº†ç‚¹
                    new THREE.Vector3(0.2, -0.4, -1.0)   // ä½™éŸ»
                ];
                
                const curve = new THREE.CatmullRomCurve3(trailPoints);
                const trailGeometry = new THREE.TubeGeometry(curve, 20, 0.05, 8, false);
                
                const trailMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9,
                    emissive: 0x444444
                });
                
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                this.camera.add(trail);
                
                // è»Œè·¡ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                let opacity = 0.9;
                const fadeTrail = () => {
                    opacity -= 0.15;
                    if (trail.material) {
                        trail.material.opacity = opacity;
                    }
                    
                    if (opacity <= 0) {
                        this.camera.remove(trail);
                    } else {
                        setTimeout(fadeTrail, 40);
                    }
                };
                
                setTimeout(fadeTrail, 100);
            }
            
            createCameraShake() {
                // æ”»æ’ƒæ™‚ã®ã‚«ãƒ¡ãƒ©ã®æºã‚ŒåŠ¹æœ
                const originalPosition = this.camera.position.clone();
                let shakeCount = 0;
                const maxShakes = 8;
                
                const shake = () => {
                    if (shakeCount < maxShakes) {
                        const intensity = 0.05 * (1 - shakeCount / maxShakes);
                        this.camera.position.x = originalPosition.x + (Math.random() - 0.5) * intensity;
                        this.camera.position.y = originalPosition.y + (Math.random() - 0.5) * intensity;
                        this.camera.position.z = originalPosition.z + (Math.random() - 0.5) * intensity;
                        
                        shakeCount++;
                        setTimeout(shake, 30);
                    } else {
                        this.camera.position.copy(originalPosition);
                    }
                };
                
                shake();
            }
            
            updateCombat() {
                // æ”»æ’ƒã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ›´æ–°
                if (this.attackCooldown > 0) {
                    this.attackCooldown = Math.max(0, this.attackCooldown - 16);
                }
                
                // é­”æ³•å¼¾ã®æ›´æ–°
                this.updateMagicProjectiles();
                
                // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°
                this.updateHitEffects();
            }
            
            updateMagicProjectiles() {
                for (let i = this.magicProjectiles.length - 1; i >= 0; i--) {
                    const projectile = this.magicProjectiles[i];
                    const userData = projectile.userData;
                    
                    // é­”æ³•å¼¾ã‚’ç§»å‹•
                    projectile.position.add(userData.direction.clone().multiplyScalar(userData.speed));
                    
                    // é­”æ³•å¼¾ã®å›è»¢ã¨ãƒ‘ãƒ«ã‚¹åŠ¹æœ
                    projectile.rotation.x += 0.1;
                    projectile.rotation.y += 0.1;
                    const scale = 1 + Math.sin(Date.now() * 0.01) * 0.2;
                    projectile.scale.setScalar(scale);
                    
                    // æ•µã¨ã®è¡çªåˆ¤å®š
                    let hit = false;
                    for (const enemy of this.enemies) {
                        if (!enemy.userData.alive) continue;
                        
                        const distance = projectile.position.distanceTo(enemy.position);
                        if (distance < 1.0) {
                            this.damageEnemy(enemy, userData.damage, 'magic');
                            this.createMagicHitEffect(projectile.position);
                            hit = true;
                            break;
                        }
                    }
                    
                    // å£ã¨ã®è¡çªåˆ¤å®š
                    if (!hit && this.isBlocked(projectile.position, 0.2, this.cellSize)) {
                        this.createMagicHitEffect(projectile.position);
                        hit = true;
                    }
                    
                    // å¯¿å‘½ãƒã‚§ãƒƒã‚¯
                    userData.life--;
                    if (hit || userData.life <= 0) {
                        this.scene.remove(projectile);
                        this.magicProjectiles.splice(i, 1);
                    }
                }
            }
            
            damageEnemy(enemy, damage, attackType) {
                enemy.userData.hp -= damage;
                
                // æ•µãŒè¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸæ™‚ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                this.createDamageReaction(enemy, attackType);
                
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                this.showDamageEffect(enemy.position, damage);
                
                if (enemy.userData.hp <= 0) {
                    this.defeatEnemy(enemy);
                }
            }
            
            createDamageReaction(enemy, attackType) {
                // æ•µã‚’å¾Œã‚ã«æŠ¼ã—å‡ºã™
                const pushDirection = new THREE.Vector3()
                    .subVectors(enemy.position, this.camera.position)
                    .normalize()
                    .multiplyScalar(0.5);
                
                const newPosition = enemy.position.clone().add(pushDirection);
                if (this.isSafePosition(newPosition, 0.8, this.cellSize)) {
                    enemy.position.copy(newPosition);
                }
                
                // æ•µã®è‰²ã‚’ä¸€ç¬å¤‰ãˆã‚‹ï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸è¡¨ç¾ï¼‰
                const originalMaterial = enemy.children[0].material;
                const damageMaterial = new THREE.MeshBasicMaterial({ 
                    color: attackType === 'sword' ? 0xff0000 : 0xffff00,
                    wireframe: true 
                });
                
                enemy.children[0].material = damageMaterial;
                setTimeout(() => {
                    enemy.children[0].material = originalMaterial;
                }, 200);
                
                // æ•µã®æŒ¯å‹•åŠ¹æœ
                const originalY = enemy.position.y;
                enemy.userData.shaking = true;
                setTimeout(() => {
                    enemy.userData.shaking = false;
                    enemy.position.y = originalY;
                }, 300);
            }
            
            createMagicHitEffect(position) {
                // é­”æ³•å¼¾ã®çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                const explosionCount = 15;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(explosionCount * 3);
                const colors = new Float32Array(explosionCount * 3);
                
                for (let i = 0; i < explosionCount * 3; i += 3) {
                    positions[i] = position.x + (Math.random() - 0.5) * 3;
                    positions[i + 1] = position.y + Math.random() * 3;
                    positions[i + 2] = position.z + (Math.random() - 0.5) * 3;
                    
                    colors[i] = 0; // R
                    colors[i + 1] = 1; // G
                    colors[i + 2] = 1; // B
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    blending: THREE.AdditiveBlending
                });
                
                const explosion = new THREE.Points(geometry, material);
                this.scene.add(explosion);
                this.hitEffects.push({
                    effect: explosion,
                    life: 30,
                    type: 'magic'
                });
            }
            
            updateHitEffects() {
                for (let i = this.hitEffects.length - 1; i >= 0; i--) {
                    const hitEffect = this.hitEffects[i];
                    hitEffect.life--;
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                    hitEffect.effect.material.opacity = hitEffect.life / 30;
                    
                    if (hitEffect.life <= 0) {
                        this.scene.remove(hitEffect.effect);
                        this.hitEffects.splice(i, 1);
                    }
                }
            }
            
            updateEnemies() {
                const currentTime = Date.now();
                const playerPos = this.camera.position;
                
                for (const enemy of this.enemies) {
                    if (!enemy.userData.alive) continue;
                    
                    const distance = playerPos.distanceTo(enemy.position);
                    
                    // æ•µã®æ”¹è‰¯ã•ã‚ŒãŸè¿·è·¯å†…ç§»å‹•AI
                    if (distance < 12) { // æ¤œçŸ¥ç¯„å›²ã‚’æ‹¡å¤§
                        if (distance > 2.5) {
                            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã£ã¦ç§»å‹•ï¼ˆè¿·è·¯ã‚’è€ƒæ…®ã—ãŸçµŒè·¯æ¢ç´¢ï¼‰
                            const bestMove = this.findBestEnemyMove(enemy, playerPos);
                            
                            if (bestMove) {
                                const speedMultiplier = Math.max(0.5, (10 - distance) / 10);
                                const moveSpeed = enemy.userData.speed * speedMultiplier;
                                
                                const newPosition = enemy.position.clone()
                                    .add(bestMove.multiplyScalar(moveSpeed));
                                
                                if (this.isSafePosition(newPosition, 0.8, this.cellSize)) {
                                    enemy.position.copy(newPosition);
                                }
                            }
                        } else {
                            // è¿‘è·é›¢ã§ã¯è¿·è·¯å†…ã§æˆ¦è¡“çš„ã«ç§»å‹•
                            const tacticalMove = this.findTacticalMove(enemy, playerPos, currentTime);
                            if (tacticalMove && this.isSafePosition(tacticalMove, 0.8, this.cellSize)) {
                                enemy.position.copy(tacticalMove);
                            }
                        }
                        
                        // æ”»æ’ƒåˆ¤å®š
                        if (distance < 2.5 && currentTime - enemy.userData.lastAttackTime > enemy.userData.attackCooldown) {
                            this.enemyAttack(enemy);
                            enemy.userData.lastAttackTime = currentTime;
                        }
                        
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ–¹ã‚’å‘ã
                        enemy.lookAt(playerPos);
                        
                    } else {
                        // å¾…æ©ŸçŠ¶æ…‹ï¼šè¿·è·¯å†…ã‚’ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«
                        this.enemyPatrol(enemy, currentTime);
                    }
                    
                    // æ•µã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    const baseY = 1;
                    const timeOffset = enemy.position.x + enemy.position.z;
                    
                    if (enemy.userData.shaking) {
                        // ãƒ€ãƒ¡ãƒ¼ã‚¸æ™‚ã®æŒ¯å‹•
                        enemy.position.y = baseY + Math.sin(currentTime * 0.1) * 0.1 + Math.random() * 0.1;
                    } else {
                        // é€šå¸¸ã®æµ®éŠåŠ¹æœ
                        enemy.position.y = baseY + Math.sin(currentTime * 0.003 + timeOffset) * 0.3;
                    }
                    
                    // å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    enemy.rotation.y += 0.02;
                    
                    // è§¦æ‰‹ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    for (let i = 1; i < enemy.children.length; i++) {
                        const tentacle = enemy.children[i];
                        tentacle.rotation.z = Math.sin(currentTime * 0.01 + i) * 0.3;
                    }
                }
            }
            
            findBestEnemyMove(enemy, playerPos) {
                // æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã†ãŸã‚ã®æœ€é©ãªæ–¹å‘ã‚’è¦‹ã¤ã‘ã‚‹
                const directions = [
                    new THREE.Vector3(1, 0, 0),   // å³
                    new THREE.Vector3(-1, 0, 0),  // å·¦
                    new THREE.Vector3(0, 0, 1),   // å‰
                    new THREE.Vector3(0, 0, -1)   // å¾Œ
                ];
                
                let bestDirection = null;
                let bestScore = -Infinity;
                
                for (const direction of directions) {
                    const testPos = enemy.position.clone().add(direction.clone().multiplyScalar(0.5));
                    
                    // ç§»å‹•å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                    if (this.isSafePosition(testPos, 0.8, this.cellSize)) {
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿‘ã¥ãæ–¹å‘ã‚’è©•ä¾¡
                        const distanceAfterMove = testPos.distanceTo(playerPos);
                        const currentDistance = enemy.position.distanceTo(playerPos);
                        const score = currentDistance - distanceAfterMove; // è·é›¢ãŒçŸ­ããªã‚‹ã»ã©é«˜ã‚¹ã‚³ã‚¢
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestDirection = direction;
                        }
                    }
                }
                
                return bestDirection;
            }
            
            findTacticalMove(enemy, playerPos, currentTime) {
                // è¿‘è·é›¢ã§ã®æˆ¦è¡“çš„ç§»å‹•ï¼ˆè¿·è·¯å†…ã§å††ã‚’æãã‚ˆã†ã«ç§»å‹•ï¼‰
                const angle = currentTime * 0.005 + enemy.position.x;
                const circleRadius = 2;
                const circleX = playerPos.x + Math.cos(angle) * circleRadius;
                const circleZ = playerPos.z + Math.sin(angle) * circleRadius;
                
                const circlePosition = new THREE.Vector3(circleX, enemy.position.y, circleZ);
                
                // å††é‹å‹•ãŒä¸å¯èƒ½ãªå ´åˆã¯ã€å·¦å³ã«ç§»å‹•
                if (!this.isSafePosition(circlePosition, 0.8, this.cellSize)) {
                    const playerDirection = new THREE.Vector3()
                        .subVectors(playerPos, enemy.position)
                        .normalize();
                    
                    const sideDirection = new THREE.Vector3(-playerDirection.z, 0, playerDirection.x);
                    const sidePosition = enemy.position.clone()
                        .add(sideDirection.multiplyScalar(0.5));
                    
                    if (this.isSafePosition(sidePosition, 0.8, this.cellSize)) {
                        return sidePosition;
                    }
                    
                    // åå¯¾å´ã‚‚è©¦ã™
                    const oppositeSidePosition = enemy.position.clone()
                        .add(sideDirection.multiplyScalar(-0.5));
                    
                    if (this.isSafePosition(oppositeSidePosition, 0.8, this.cellSize)) {
                        return oppositeSidePosition;
                    }
                }
                
                return circlePosition;
            }
            
            enemyPatrol(enemy, currentTime) {
                // æ•µã®ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«è¡Œå‹•ï¼ˆè¿·è·¯å†…ã‚’æ­©ãå›ã‚‹ï¼‰
                if (!enemy.userData.patrolTarget || Math.random() < 0.02) {
                    // æ–°ã—ã„ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ç›®æ¨™ã‚’è¨­å®š
                    const directions = [
                        new THREE.Vector3(2, 0, 0),
                        new THREE.Vector3(-2, 0, 0),
                        new THREE.Vector3(0, 0, 2),
                        new THREE.Vector3(0, 0, -2)
                    ];
                    
                    const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                    const targetPos = enemy.position.clone().add(randomDirection);
                    
                    if (this.isSafePosition(targetPos, 0.8, this.cellSize)) {
                        enemy.userData.patrolTarget = targetPos;
                    }
                }
                
                // ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ç›®æ¨™ã«å‘ã‹ã£ã¦ç§»å‹•
                if (enemy.userData.patrolTarget) {
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.userData.patrolTarget, enemy.position)
                        .normalize();
                    
                    const moveSpeed = enemy.userData.speed * 0.3; // ã‚†ã£ãã‚Šç§»å‹•
                    const newPosition = enemy.position.clone()
                        .add(direction.multiplyScalar(moveSpeed));
                    
                    if (this.isSafePosition(newPosition, 0.8, this.cellSize)) {
                        enemy.position.copy(newPosition);
                        
                        // ç›®æ¨™ã«åˆ°é”ã—ãŸã‚‰ã‚¯ãƒªã‚¢
                        if (enemy.position.distanceTo(enemy.userData.patrolTarget) < 1) {
                            enemy.userData.patrolTarget = null;
                        }
                    } else {
                        // ç§»å‹•ã§ããªã„å ´åˆã¯ç›®æ¨™ã‚’ã‚¯ãƒªã‚¢
                        enemy.userData.patrolTarget = null;
                    }
                }
            }
            
            enemyAttack(enemy) {
                const damage = enemy.userData.damage;
                this.takeDamage(damage);
                
                // æ”»æ’ƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                this.showAttackEffect(enemy.position);
            }
            
            takeDamage(damage) {
                const currentTime = Date.now();
                if (currentTime - this.lastDamageTime < 1000) return; // ç„¡æ•µæ™‚é–“
                
                this.lastDamageTime = currentTime;
                this.playerHP = Math.max(0, this.playerHP - damage);
                
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆç”»é¢ã‚’èµ¤ãå…‰ã‚‰ã›ã‚‹ï¼‰
                this.showPlayerDamageEffect();
                
                if (this.playerHP <= 0) {
                    this.gameOver();
                }
            }
            
            defeatEnemy(enemy) {
                enemy.userData.alive = false;
                
                // æ•µã‚’å€’ã—ãŸã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                this.showDefeatEffect(enemy.position);
                
                // æ•µã‚’å‰Šé™¤
                this.scene.remove(enemy);
                const index = this.enemies.indexOf(enemy);
                if (index > -1) {
                    this.enemies.splice(index, 1);
                }
            }
            
            showDamageEffect(position, damage) {
                // ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å€¤ã‚’è¡¨ç¤ºï¼ˆç°¡å˜ãªå®Ÿè£…ï¼‰
                console.log(`${damage} ãƒ€ãƒ¡ãƒ¼ã‚¸!`);
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                const particleCount = 10;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = position.x + (Math.random() - 0.5) * 2;
                    positions[i + 1] = position.y + Math.random() * 2;
                    positions[i + 2] = position.z + (Math.random() - 0.5) * 2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: 0xff0000,
                    size: 0.2
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                
                setTimeout(() => {
                    this.scene.remove(particles);
                }, 1000);
            }
            
            showAttackEffect(position) {
                console.log('æ•µã®æ”»æ’ƒ!');
            }
            
            showPlayerDamageEffect() {
                // ç”»é¢ã‚’ä¸€ç¬èµ¤ãã™ã‚‹åŠ¹æœ
                document.body.style.background = 'rgba(255,0,0,0.3)';
                setTimeout(() => {
                    document.body.style.background = '';
                }, 200);
            }
            
            showDefeatEffect(position) {
                console.log('æ•µã‚’å€’ã—ãŸ!');
            }
            
            gameOver() {
                this.gameStarted = false;
                document.exitPointerLock();
                
                const gameOverDiv = document.createElement('div');
                gameOverDiv.innerHTML = `
                    <div style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: linear-gradient(135deg, #ff0000, #aa0000);
                        color: white;
                        padding: 40px;
                        border-radius: 20px;
                        text-align: center;
                        font-size: 2rem;
                        font-weight: bold;
                        z-index: 1000;
                    ">
                        ğŸ’€ GAME OVER ğŸ’€<br>
                        <div style="font-size: 1.2rem; margin-top: 20px;">
                            æ·±æµ·ã®é­”ç‰©ã«å€’ã•ã‚ŒãŸ...<br>
                            ç«  ${this.currentLevel} ã§åŠ›å°½ããŸ
                        </div>
                        <button onclick="location.reload()" style="
                            background: #ffffff;
                            color: #ff0000;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 25px;
                            font-size: 1.1rem;
                            cursor: pointer;
                            margin-top: 25px;
                        ">
                            æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã™
                        </button>
                    </div>
                `;
                document.body.appendChild(gameOverDiv);
            }
            
            gameWin() {
                const endTime = Date.now();
                const totalTime = Math.floor((endTime - this.startTime) / 1000);
                
                this.gameStarted = false;
                document.exitPointerLock();
                
                // æ´¾æ‰‹ãªãŠç¥ã„æ¼”å‡ºã‚’é–‹å§‹
                this.startCelebration(totalTime);
            }
            
            startCelebration(totalTime) {
                // ç¥ç¦ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å¤§é‡ç”Ÿæˆ
                this.createCelebrationParticles();
                
                // å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                this.showVictoryMessage(totalTime);
                
                // ã‚«ãƒ¡ãƒ©ã‚’è‡ªå‹•å›è»¢
                this.celebrationRotation = 0;
                this.isCelebrating = true;
                this.levelCompleted = true;
                
                // 5ç§’å¾Œã«ãƒªã‚»ãƒƒãƒˆ
                setTimeout(() => {
                    this.endCelebration();
                }, 5000);
            }
            
            showStoryIntro() {
                const story = this.storyMessages[this.currentLevel];
                if (!story) return;
                
                // ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ç´¹ä»‹ç”»é¢ã‚’ä½œæˆ
                const storyDiv = document.createElement('div');
                storyDiv.id = 'story-intro';
                storyDiv.innerHTML = `
                    <div style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(135deg, rgba(0,20,40,0.95), rgba(0,60,100,0.95));
                        color: white;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 2000;
                        backdrop-filter: blur(10px);
                    ">
                        <div style="
                            text-align: center;
                            max-width: 600px;
                            padding: 40px;
                            background: linear-gradient(135deg, rgba(0,188,212,0.2), rgba(77,208,225,0.2));
                            border-radius: 20px;
                            border: 2px solid rgba(77,208,225,0.5);
                            animation: storyFadeIn 1s ease-out;
                        ">
                            <h2 style="font-size: 2.5rem; margin-bottom: 30px; color: #4dd0e1;">
                                ${story.title}
                            </h2>
                            <p style="font-size: 1.3rem; line-height: 1.6; margin-bottom: 30px; white-space: pre-line;">
                                ${story.intro}
                            </p>
                            <div style="font-size: 1rem; opacity: 0.8; margin-bottom: 30px;">
                                ãƒ¬ãƒ™ãƒ« ${this.currentLevel} / ${this.maxLevel}
                            </div>
                            <button id="story-continue" style="
                                background: linear-gradient(135deg, #00bcd4, #4dd0e1);
                                color: white;
                                border: none;
                                padding: 15px 30px;
                                border-radius: 25px;
                                font-size: 1.1rem;
                                cursor: pointer;
                                transition: all 0.3s ease;
                            ">
                                å†’é™ºã‚’å§‹ã‚ã‚‹
                            </button>
                        </div>
                    </div>
                `;
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨CSS
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes storyFadeIn {
                        0% { opacity: 0; transform: translateY(30px); }
                        100% { opacity: 1; transform: translateY(0); }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(storyDiv);
                
                // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§é–‹å§‹
                document.getElementById('story-continue').addEventListener('click', () => {
                    storyDiv.remove();
                });
            }
            
            createCelebrationParticles() {
                // èŠ±ç«ã®ã‚ˆã†ãªçˆ†ç™ºãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                const particleCount = 500;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const velocities = [];
                
                const goalPos = this.goal.position;
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // ã‚´ãƒ¼ãƒ«ä½ç½®ã‹ã‚‰æ”¾å°„çŠ¶ã«
                    positions[i3] = goalPos.x;
                    positions[i3 + 1] = goalPos.y;
                    positions[i3 + 2] = goalPos.z;
                    
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªè‰²ï¼ˆé‡‘ã€é’ã€èµ¤ã€ç·‘ï¼‰
                    const colorChoice = Math.random();
                    if (colorChoice < 0.25) {
                        colors[i3] = 1; colors[i3 + 1] = 0.8; colors[i3 + 2] = 0; // é‡‘
                    } else if (colorChoice < 0.5) {
                        colors[i3] = 0; colors[i3 + 1] = 0.5; colors[i3 + 2] = 1; // é’
                    } else if (colorChoice < 0.75) {
                        colors[i3] = 1; colors[i3 + 1] = 0; colors[i3 + 2] = 0; // èµ¤
                    } else {
                        colors[i3] = 0; colors[i3 + 1] = 1; colors[i3 + 2] = 0; // ç·‘
                    }
                    
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
                    velocities.push({
                        x: (Math.random() - 0.5) * 10,
                        y: Math.random() * 15 + 5,
                        z: (Math.random() - 0.5) * 10
                    });
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                this.celebrationParticles = new THREE.Points(geometry, material);
                this.celebrationVelocities = velocities;
                this.scene.add(this.celebrationParticles);
            }
            
            showVictoryMessage(totalTime) {
                const story = this.storyMessages[this.currentLevel];
                const isLastLevel = this.currentLevel >= this.maxLevel;
                
                // HTMLè¦ç´ ã§å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                const victoryDiv = document.createElement('div');
                victoryDiv.id = 'victory-message';
                victoryDiv.innerHTML = `
                    <div style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
                        color: white;
                        padding: 40px;
                        border-radius: 20px;
                        text-align: center;
                        font-size: 2rem;
                        font-weight: bold;
                        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                        z-index: 1000;
                        animation: victoryPulse 2s ease-in-out infinite;
                        max-width: 600px;
                    ">
                        ğŸ‰ ãƒ¬ãƒ™ãƒ« ${this.currentLevel} ã‚¯ãƒªã‚¢! ğŸ‰<br>
                        <div style="font-size: 1.3rem; margin-top: 20px;">
                            ã‚¿ã‚¤ãƒ : ${totalTime}ç§’
                        </div>
                        <div style="font-size: 1rem; margin-top: 20px; line-height: 1.4; white-space: pre-line; opacity: 0.95;">
                            ${story.complete}
                        </div>
                        ${!isLastLevel ? `
                        <button id="next-level-btn" style="
                            background: linear-gradient(135deg, #feca57, #ff9f43);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 25px;
                            font-size: 1.1rem;
                            cursor: pointer;
                            margin-top: 25px;
                            transition: all 0.3s ease;
                        ">
                            æ¬¡ã®ç« ã¸é€²ã‚€ â¤
                        </button>
                        ` : `
                        <div style="font-size: 1.2rem; margin-top: 25px; color: #feca57;">
                            ğŸ† å…¨ã¦ã®ç« ã‚’ã‚¯ãƒªã‚¢ï¼å›ã¯çœŸã®æµ·å­¦ãƒã‚¹ã‚¿ãƒ¼ã ï¼ ğŸ†
                        </div>
                        <button id="restart-game-btn" style="
                            background: linear-gradient(135deg, #26c6da, #00bcd4);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 25px;
                            font-size: 1.1rem;
                            cursor: pointer;
                            margin-top: 15px;
                            transition: all 0.3s ease;
                        ">
                            æœ€åˆã‹ã‚‰å†’é™ºã‚’å§‹ã‚ã‚‹
                        </button>
                        `}
                    </div>
                `;
                
                // CSSã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes victoryPulse {
                        0%, 100% { transform: translate(-50%, -50%) scale(1); }
                        50% { transform: translate(-50%, -50%) scale(1.05); }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(victoryDiv);
                
                // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
                if (!isLastLevel) {
                    const nextBtn = document.getElementById('next-level-btn');
                    if (nextBtn) {
                        nextBtn.addEventListener('click', () => {
                            this.nextLevel();
                        });
                    }
                } else {
                    const restartBtn = document.getElementById('restart-game-btn');
                    if (restartBtn) {
                        restartBtn.addEventListener('click', () => {
                            this.restartGame();
                        });
                    }
                }
            }
            
            nextLevel() {
                this.currentLevel++;
                this.playerHP = Math.min(this.maxHP, this.playerHP + 30); // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã§HPå›å¾©
                this.endCelebration();
                this.resetPlayerPosition();
                this.clearMaze();
                this.generateComplexMaze();
                this.createMaze3D();
                this.updateHUD();
            }
            
            restartGame() {
                this.currentLevel = 1;
                this.playerHP = this.maxHP; // HPå®Œå…¨å›å¾©
                this.endCelebration();
                this.resetPlayerPosition();
                this.clearMaze();
                this.generateComplexMaze();
                this.createMaze3D();
                this.updateHUD();
            }
            
            resetPlayerPosition() {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¹ã‚¿ãƒ¼ãƒˆä½ç½®ã«æˆ»ã™
                this.camera.position.set(6, 2, 6);
                this.camera.rotation.set(0, 0, 0);
                this.rotationX = 0;
                this.rotationY = 0;
            }
            
            clearMaze() {
                // æ—¢å­˜ã®è¿·è·¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤
                const objectsToRemove = [];
                this.scene.traverse((child) => {
                    if (child.type === 'LineSegments' && child !== this.particles) {
                        objectsToRemove.push(child);
                    }
                });
                
                objectsToRemove.forEach(obj => {
                    this.scene.remove(obj);
                });
                
                // ã‚´ãƒ¼ãƒ«ã‚‚å‰Šé™¤
                if (this.goal) {
                    this.scene.remove(this.goal);
                    this.goal = null;
                }
            }
            
            endCelebration() {
                this.isCelebrating = false;
                this.levelCompleted = false;
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
                if (this.celebrationParticles) {
                    this.scene.remove(this.celebrationParticles);
                    this.celebrationParticles = null;
                }
                
                // å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤
                const victoryMsg = document.getElementById('victory-message');
                if (victoryMsg) {
                    victoryMsg.remove();
                }
                
                // ä»–ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚‚å‰Šé™¤
                const storyIntro = document.getElementById('story-intro');
                if (storyIntro) {
                    storyIntro.remove();
                }
                
                // ãƒ¬ãƒ™ãƒ«ãŒå®Œäº†ã—ã¦ã„ãªã„å ´åˆã®ã¿ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                if (!this.levelCompleted) {
                    document.getElementById('startButton').style.display = 'block';
                }
            }
            
            updateTimer() {
                if (!this.gameStarted || !this.startTime) return;
                
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                document.getElementById('timer').textContent = elapsed;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updateMovement();
                this.updateTimer();
                this.updateCombat();
                this.updateEnemies();
                
                // ã‚´ãƒ¼ãƒ«ã®å›è»¢ï¼ˆãŠç¥ã„ä¸­ã¯ã‚ˆã‚Šæ¿€ã—ãï¼‰
                if (this.goal) {
                    this.goal.rotation.y += this.isCelebrating ? 0.05 : 0.01;
                }
                
                // ãŠç¥ã„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.isCelebrating && this.celebrationParticles) {
                    this.updateCelebrationParticles();
                    
                    // ã‚«ãƒ¡ãƒ©ã®è‡ªå‹•å›è»¢
                    this.celebrationRotation += 0.02;
                    const radius = 8;
                    const goalPos = this.goal.position;
                    this.camera.position.x = goalPos.x + Math.cos(this.celebrationRotation) * radius;
                    this.camera.position.z = goalPos.z + Math.sin(this.celebrationRotation) * radius;
                    this.camera.lookAt(goalPos);
                }
                
                // æµ·ä¸­ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.particles) {
                    this.particles.rotation.y += 0.002;
                    const positions = this.particles.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] += 0.01; // ã‚†ã£ãã‚Šä¸Šæ˜‡
                        if (positions[i] > 20) {
                            positions[i] = 0; // ä¸Šã¾ã§è¡Œã£ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
                        }
                    }
                    this.particles.geometry.attributes.position.needsUpdate = true;
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            updateCelebrationParticles() {
                const positions = this.celebrationParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < this.celebrationVelocities.length; i++) {
                    const i3 = i * 3;
                    const velocity = this.celebrationVelocities[i];
                    
                    // ä½ç½®ã‚’æ›´æ–°
                    positions[i3] += velocity.x * 0.1;
                    positions[i3 + 1] += velocity.y * 0.1;
                    positions[i3 + 2] += velocity.z * 0.1;
                    
                    // é‡åŠ›åŠ¹æœ
                    velocity.y -= 0.5;
                    
                    // ç©ºæ°—æŠµæŠ—
                    velocity.x *= 0.98;
                    velocity.z *= 0.98;
                }
                
                this.celebrationParticles.geometry.attributes.position.needsUpdate = true;
            }
        }
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, creating game...');
            new SimpleMaze3D();
        });
    </script>
</body>
</html>
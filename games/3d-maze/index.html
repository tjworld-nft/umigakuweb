<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dæµ·æ´‹è¿·è·¯ã‚²ãƒ¼ãƒ ï½œä¸‰æµ¦æµ·ã®å­¦æ ¡ ç‰¹åˆ¥å‰²å¼•ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³</title>
    
    <!-- SEO & OGP -->
    <meta name="description" content="10ç« ã®3Dæµ·æ´‹è¿·è·¯ã‚’æ”»ç•¥ã—ã¦æµ·å­¦ãƒã‚¹ã‚¿ãƒ¼ã«ãªã‚ã†ï¼ã‚¯ãƒªã‚¢ã™ã‚‹ã¨2ãƒ“ãƒ¼ãƒãƒ€ã‚¤ãƒ“ãƒ³ã‚°5%OFFç‰¹å…¸ãŒã‚‚ã‚‰ãˆã‚‹ï¼">
    <meta property="og:title" content="3Dæµ·æ´‹è¿·è·¯ã‚²ãƒ¼ãƒ ï½œä¸‰æµ¦æµ·ã®å­¦æ ¡ ç‰¹åˆ¥å‰²å¼•ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³">
    <meta property="og:description" content="10ç« ã®3Dæµ·æ´‹è¿·è·¯ã‚’æ”»ç•¥ã—ã¦æµ·å­¦ãƒã‚¹ã‚¿ãƒ¼ã«ãªã‚ã†ï¼ã‚¯ãƒªã‚¢ã™ã‚‹ã¨2ãƒ“ãƒ¼ãƒãƒ€ã‚¤ãƒ“ãƒ³ã‚°5%OFFç‰¹å…¸ãŒã‚‚ã‚‰ãˆã‚‹ï¼">
    <meta property="og:type" content="website">
    <meta property="og:image" content="assets/img/game-img/meiro.png">
    <meta name="twitter:card" content="summary_large_image">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #001122;
            font-family: Arial, sans-serif;
            color: white;
            width: 100vw;
            height: 100vh;
        }
        
        .hud {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 999999;
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 20px;
            border-radius: 12px;
            border: 3px solid #00ffff;
            min-width: 300px;
            width: fit-content;
            max-width: 400px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.5);
            font-size: 15px;
            font-weight: bold;
            line-height: 1.5;
            white-space: nowrap;
            pointer-events: none;
        }
        
        .hud div {
            margin-bottom: 4px;
        }
        
        .hud div:last-child {
            margin-bottom: 0;
        }
        
        .start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #00ffff;
            color: black;
            padding: 20px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            z-index: 200;
        }
        
        .controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 999999;
            background: rgba(0, 0, 0, 0.95);
            padding: 12px 18px;
            border-radius: 12px;
            border: 3px solid #00ffff;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.5);
            font-size: 14px;
            font-weight: bold;
            line-height: 1.4;
            min-width: 220px;
            width: fit-content;
            pointer-events: none;
        }
        
        .game-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 999999;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        
        .control-btn {
            background: rgba(0, 255, 255, 0.9);
            color: black;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 2px solid #00ffff;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.5);
        }
        
        .control-btn.danger {
            background: rgba(255, 100, 100, 0.9);
            border-color: #ff6464;
            color: white;
        }
        
        .control-btn.danger:hover {
            background: rgba(255, 50, 50, 0.9);
            box-shadow: 0 5px 15px rgba(255, 100, 100, 0.5);
        }
        
        .time-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999999;
            background: rgba(255, 0, 0, 0.95);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 3px solid #ff0000;
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.5);
            animation: pulse 1s ease-in-out infinite;
            display: none;
        }
        
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        .mobile-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000000;
            text-align: center;
            padding: 20px;
        }
        
        .mobile-warning-content {
            background: linear-gradient(135deg, #ff6b9d, #ff9f43);
            padding: 30px;
            border-radius: 20px;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .mobile-warning h2 {
            margin-bottom: 20px;
            font-size: 1.5rem;
        }
        
        .mobile-warning p {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        
        .pointer-lock-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999999;
            background: rgba(0, 255, 255, 0.95);
            color: black;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 3px solid #00ffff;
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5);
            animation: notification-pulse 2s ease-in-out infinite;
            display: none;
            max-width: 400px;
        }
        
        @keyframes notification-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
            50% { transform: translate(-50%, -50%) scale(1.02); opacity: 1; }
        }
        
        .controls div {
            margin-bottom: 3px;
        }
        
        .controls div:last-child {
            margin-bottom: 0;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 480px) {
            .hud {
                font-size: 12px;
                min-width: 250px;
                max-width: 300px;
                padding: 10px 12px;
                top: 5px;
                left: 5px;
            }
            
            .controls {
                font-size: 11px;
                min-width: 180px;
                padding: 10px 12px;
                bottom: 5px;
                left: 5px;
            }
        }
        
        @media (max-width: 320px) {
            .hud {
                font-size: 11px;
                min-width: 220px;
                max-width: 280px;
                padding: 8px 10px;
            }
            
            .controls {
                font-size: 10px;
                min-width: 160px;
                padding: 8px 10px;
            }
        }
        
        #canvas {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 1 !important;
            display: block !important;
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            outline: none !important;
        }
        
        /* Header & Footer Styles */
        .header {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(224, 247, 250, 0.95) 100%);
            backdrop-filter: blur(15px);
            padding: 1rem 0;
            box-shadow: 0 4px 30px rgba(0, 188, 212, 0.3);
            border-bottom: 2px solid rgba(255, 107, 157, 0.2);
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100000;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #00bcd4 0%, #26c6da 50%, #4dd0e1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-decoration: none;
        }
        
        .nav-link {
            color: #006064;
            text-decoration: none;
            font-weight: 500;
            padding: 0.5rem 1.5rem;
            border-radius: 25px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(224, 247, 250, 0.6) 100%);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .nav-link:hover {
            color: white;
            background: linear-gradient(135deg, #ff6b9d, #ff9f43);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 107, 157, 0.4);
        }
        
        .game-title-overlay {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 99999;
            background: linear-gradient(135deg, rgba(0, 188, 212, 0.9) 0%, rgba(255, 107, 157, 0.9) 100%);
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.3rem;
            font-weight: bold;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0, 188, 212, 0.4);
            text-align: center;
        }
        
        .footer {
            background: linear-gradient(135deg, rgba(0, 96, 100, 0.95) 0%, rgba(0, 96, 100, 0.98) 100%);
            color: white;
            text-align: center;
            padding: 2rem 0;
            position: fixed;
            bottom: 0;
            width: 100%;
            z-index: 99999;
            backdrop-filter: blur(10px);
        }
        
        /* ã‚²ãƒ¼ãƒ é–‹å§‹å‰ã¯è¡¨ç¤ºã€é–‹å§‹å¾Œã¯éè¡¨ç¤º */
        .header.game-started,
        .footer.game-started,
        .game-title-overlay.game-started {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Mobile Warning -->
    <div class="mobile-warning" id="mobileWarning">
        <div class="mobile-warning-content">
            <h2>ğŸ’» PCå°‚ç”¨ã‚²ãƒ¼ãƒ ã§ã™</h2>
            <p>ã“ã®ã‚²ãƒ¼ãƒ ã¯<strong>PCï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ãƒ»ãƒãƒ¼ãƒˆãƒ‘ã‚½ã‚³ãƒ³ï¼‰</strong>ã§ã®ãƒ—ãƒ¬ã‚¤å°‚ç”¨ã§ã™ã€‚</p>
            <p>ğŸ“± ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã§ã¯ãƒ—ãƒ¬ã‚¤ã§ãã¾ã›ã‚“ã€‚</p>
            <p>ğŸ–±ï¸ ãƒã‚¦ã‚¹ã¨ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™ã€‚</p>
            <p>PCã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãŠæ¥½ã—ã¿ãã ã•ã„ï¼</p>
            <br>
            <a href="/games/" style="color: white; text-decoration: none; background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 10px; display: inline-block;">ã‚²ãƒ¼ãƒ ä¸€è¦§ã«æˆ»ã‚‹</a>
        </div>
    </div>
    <!-- Header -->
    <header class="header" id="gameHeader">
        <div class="header-content">
            <a href="/" class="logo">ğŸŒŠ ä¸‰æµ¦æµ·ã®å­¦æ ¡</a>
            <a href="/games/" class="nav-link">ã‚²ãƒ¼ãƒ ä¸€è¦§ã«æˆ»ã‚‹</a>
        </div>
    </header>
    
    <!-- Game Title Overlay -->
    <div class="game-title-overlay" id="gameTitleOverlay">
        ğŸ´â€â˜ ï¸ 3Dæµ·æ´‹è¿·è·¯ã‚²ãƒ¼ãƒ  - æµ·å­¦ãƒã‚¹ã‚¿ãƒ¼ã¸ã®é“ ğŸ´â€â˜ ï¸
    </div>
    <div class="hud" style="
        position: absolute !important;
        top: 120px !important;
        left: 20px !important;
        z-index: 999999 !important;
        background: rgba(0, 0, 0, 0.95) !important;
        color: white !important;
        padding: 15px 20px !important;
        border-radius: 12px !important;
        border: 3px solid #00ffff !important;
        font-size: 15px !important;
        font-weight: bold !important;
        min-width: 300px !important;
        width: auto !important;
        box-shadow: 0 8px 25px rgba(0, 255, 255, 0.5) !important;
        pointer-events: none !important;
        display: block !important;
        visibility: visible !important;
    ">
        <div style="margin-bottom: 5px;">ğŸŒŠ æµ·å­¦ã®è¿·å®®</div>
        <div style="margin-bottom: 5px;">ç« : <span id="currentLevel">1</span> / <span id="maxLevel">10</span></div>
        <div style="margin-bottom: 5px;">â¤ï¸ HP: <span id="playerHP">100</span> / <span id="maxHP">100</span></div>
        <div style="margin-bottom: 5px;">â­ Lv: <span id="playerLevel">1</span> (EXP: <span id="experience">0</span>/<span id="experienceToNext">100</span>)</div>
        <div style="margin-bottom: 5px;">ğŸ”® é­”åŠ›: <span id="magicPower">20</span> | âš¡ ã‚³ãƒ³ãƒœ: <span id="combo">0</span></div>
        <div style="margin-bottom: 5px;">ğŸ† ã‚¹ã‚³ã‚¢: <span id="score">0</span></div>
        <div style="margin-bottom: 5px;">ğŸ§­ æ–¹ä½: <span id="compass">åŒ—</span></div>
        <div style="margin-bottom: 0;">â° æ®‹ã‚Šæ™‚é–“: <span id="remainingTime">5:00</span></div>
    </div>
    
    <!-- ã‚²ãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
    <div class="game-controls" id="gameControls" style="display: none;">
        <button class="control-btn" onclick="game.returnToWebsite()">ğŸŒ ã‚µã‚¤ãƒˆã«æˆ»ã‚‹</button>
        <button class="control-btn danger" onclick="game.quitGame()">âŒ ã‚²ãƒ¼ãƒ çµ‚äº†</button>
    </div>
    
    <!-- æ™‚é–“è­¦å‘Š -->
    <div class="time-warning" id="timeWarning">
        âš ï¸ æ™‚é–“ãŒæ®‹ã‚Šå°‘ãªã„ã§ã™ï¼ âš ï¸<br>
        æ€¥ã„ã§ã‚´ãƒ¼ãƒ«ã‚’ç›®æŒ‡ã—ã¦ãã ã•ã„ï¼
    </div>
    
    <!-- ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯è§£é™¤é€šçŸ¥ -->
    <div class="pointer-lock-notification" id="pointerLockNotification">
        ğŸ”“ è¦–ç‚¹ãƒ­ãƒƒã‚¯ãŒè§£é™¤ã•ã‚Œã¾ã—ãŸ<br>
        <small>ç”»é¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å†ã³è¦–ç‚¹æ“ä½œã‚’é–‹å§‹</small>
    </div>
    
    <!-- ãƒŸãƒ‹ãƒãƒƒãƒ— -->
    <div id="minimap" style="
        position: fixed !important;
        top: 20px !important;
        right: 20px !important;
        width: 150px !important;
        height: 150px !important;
        background: rgba(0, 0, 0, 0.9) !important;
        border: 3px solid #00ffff !important;
        border-radius: 8px !important;
        z-index: 999998 !important;
        overflow: hidden !important;
    ">
        <canvas id="minimapCanvas" width="150" height="150" style="
            width: 100% !important;
            height: 100% !important;
            display: block !important;
        "></canvas>
    </div>
    
    <div class="controls" style="
        position: absolute !important;
        bottom: 20px !important;
        left: 20px !important;
        z-index: 999999 !important;
        background: rgba(0, 0, 0, 0.95) !important;
        color: white !important;
        padding: 12px 18px !important;
        border-radius: 12px !important;
        border: 3px solid #00ffff !important;
        font-size: 14px !important;
        font-weight: bold !important;
        min-width: 220px !important;
        width: auto !important;
        box-shadow: 0 8px 25px rgba(0, 255, 255, 0.5) !important;
        pointer-events: none !important;
        display: block !important;
        visibility: visible !important;
    ">
        <div style="margin-bottom: 3px;">ğŸ–±ï¸ ãƒã‚¦ã‚¹: è¦–ç‚¹ç§»å‹•</div>
        <div style="margin-bottom: 3px;">âŒ¨ï¸ WASD: ç§»å‹•</div>
        <div style="margin-bottom: 3px;">ğŸ”® ã‚¹ãƒšãƒ¼ã‚¹: é­”æ³•å¼¾</div>
        <div style="margin-bottom: 3px;">ğŸ”“ ESC: è¦–ç‚¹ãƒ­ãƒƒã‚¯è§£é™¤</div>
        <div style="margin-bottom: 0;">ğŸ¯ ã‚´ãƒ¼ãƒ«: èµ¤ã„ã‚­ãƒ¥ãƒ¼ãƒ–</div>
    </div>
    
    
    <canvas id="canvas"></canvas>
    
    <!-- Footer -->
    <footer class="footer" id="gameFooter">
        <div style="max-width: 1200px; margin: 0 auto; padding: 0 20px;">
            <p>&copy; 2025 ä¸‰æµ¦æµ·ã®å­¦æ ¡. All rights reserved.</p>
            <p style="margin-top: 0.5rem;">ğŸ“ 046-880-0835 | ğŸ“§ info@miura-diving.com</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.skypack.dev/gsap@3.12.2"></script>
    <script>
        class SimpleMaze3D {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.mazeSize = 11;
                this.cellSize = 4;
                this.wallHeight = 4;
                
                this.maze = [];
                this.startTime = null;
                this.gameStarted = false;
                this.pointerLocked = false;
                
                this.keys = {};
                this.moveSpeed = 0.1;
                
                // ãƒã‚¦ã‚¹åˆ¶å¾¡
                this.mouseX = 0;
                this.mouseY = 0;
                this.rotationX = 0;
                this.rotationY = 0;
                
                // ãƒ¬ãƒ™ãƒ«ã‚·ã‚¹ãƒ†ãƒ 
                this.currentLevel = 1;
                this.maxLevel = 10;
                this.levelCompleted = false;
                
                // ã‚¿ã‚¤ãƒ ãƒªãƒŸãƒƒãƒˆã‚·ã‚¹ãƒ†ãƒ 
                this.timeLimit = 300; // 5åˆ†ï¼ˆ300ç§’ï¼‰
                this.remainingTime = this.timeLimit;
                this.isGameOver = false;
                
                // ã‚¹ãƒˆãƒ¼ãƒªãƒ¼è¦ç´ 
                this.storyMessages = this.initStoryMessages();
                
                // Player
                this.playerHP = 100;
                this.maxHP = 100;
                this.lastDamageTime = 0;
                
                // ã‚¹ã‚­ãƒ«ã‚·ã‚¹ãƒ†ãƒ 
                this.playerLevel = 1;
                this.experience = 0;
                this.experienceToNext = 100;
                this.magicPower = 20;
                this.criticalChance = 0.1;
                
                // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ 
                this.powerUps = [];
                this.activePowerUps = {};
                
                // ã‚¹ã‚³ã‚¢
                this.score = 0;
                this.combo = 0;
                this.comboTime = 0;
                
                // Combat system
                this.attackCooldown = 0;
                this.isAttacking = false;
                this.magicProjectiles = [];
                this.hitEffects = [];
                
                // Enemies
                this.enemies = [];
                
                // ãƒŸãƒ‹ãƒãƒƒãƒ—ã¨ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
                this.exploredMap = [];
                this.minimapCanvas = null;
                this.minimapCtx = null;
                this.playerDirection = 0; // ãƒ©ã‚¸ã‚¢ãƒ³
                
                // ãƒ¢ãƒã‚¤ãƒ«æ¤œå‡ºã¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
                this.isMobile = this.detectMobile();
                
                this.init();
            }
            
            initStoryMessages() {
                return {
                    1: {
                        title: "ç¬¬1ç« ï¼šç›®è¦šã‚",
                        intro: "æ°—ãŒã¤ãã¨ã€å›ã¯è¦‹çŸ¥ã‚‰ã¬é’ã„è¿·è·¯ã«å›šã‚ã‚Œã¦ã„ãŸ...\næ‰‹ã«ã¯é­”æ³•ã®åŠ›ãŒå®¿ã£ã¦ã„ã‚‹ã€‚ãã—ã¦ã€ä¸æ€è­°ãªåŠ›ã‚’æ„Ÿã˜ã‚‹...\n\nğŸ”® ã‚¹ãƒšãƒ¼ã‚¹: é­”æ³•å¼¾\nâ¤ï¸ HP: 100",
                        complete: "å°ã•ãªæµ·ç£ãŸã¡ã‚’é€€ã‘ã€æœ€åˆã®æ‰‰ãŒé–‹ã„ãŸ...\nã ãŒã€ã“ã‚Œã¯å§‹ã¾ã‚Šã«éããªã„ã€‚",
                        enemies: ["ã‚·ãƒ¼ã‚¢ãƒãƒ¢ãƒ", "å°ã•ãªã‚¯ãƒ©ã‚²"]
                    },
                    2: {
                        title: "ç¬¬2ç« ï¼šæ·±æµ·ã®å…¥ã‚Šå£", 
                        intro: "è¿·è·¯ã¯å¾ã€…ã«è¤‡é›‘ã«ãªã‚Šã€ã‚ˆã‚Šå±é™ºãªç”Ÿç‰©ãŒç¾ã‚Œå§‹ã‚ãŸã€‚\næ·±æµ·ã®è¬ãŒå›ã‚’å¾…ã¡å—ã‘ã¦ã„ã‚‹ã€‚\n\næµ·æµã«æ°—ã‚’ã¤ã‘ã‚...æ•µã¯å›ã‚’å–ã‚Šå›²ã‚‚ã†ã¨ã—ã¦ã„ã‚‹ã€‚",
                        complete: "æµ·æµã®éŸ³ãŒèã“ãˆã¦ããŸ...æ›´ãªã‚‹æ·±ã¿ã¸ã€‚\nå›ã®é­”æ³•ãŒç£¨ã‹ã‚Œã¦ãã¦ã„ã‚‹ã€‚",
                        enemies: ["é›»æ°—ã‚¦ãƒŠã‚®", "æ¯’ã‚¯ãƒ©ã‚²", "å°ã‚µãƒ¡"]
                    },
                    3: {
                        title: "ç¬¬3ç« ï¼šæ½®ã®æµã‚Œ",
                        intro: "æ½®ã®æµã‚ŒãŒè¿·è·¯ã‚’è¤‡é›‘ã«ã—ã€æ•µã‚‚å·§å¦™ã«ãªã£ã¦ããŸã€‚\nå†·é™ã•ã‚’ä¿ã¡ã€æˆ¦ç•¥çš„ã«æˆ¦ãŠã†ã€‚\n\nè¤‡æ•°ã®æ•µãŒåŒæ™‚ã«è¥²ã„ã‹ã‹ã£ã¦ãã‚‹...",
                        complete: "æ½®æµã‚’èª­ã¿ã€æ•µã®å‹•ãã‚’äºˆæ¸¬ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚\nå›ã¯ç¢ºå®Ÿã«æˆé•·ã—ã¦ã„ã‚‹ã€‚",
                        enemies: ["å·¨å¤§ãƒ’ãƒˆãƒ‡", "ç¾¤ã‚Œã‚µãƒ¡", "æ·±æµ·ã‚¤ã‚«"]
                    },
                    4: {
                        title: "ç¬¬4ç« ï¼šæ·±æµ·ã®å£°",
                        intro: "æ·±æµ·ã‹ã‚‰è¬ã‚ã„ãŸå£°ãŒèã“ãˆã‚‹ã€‚\nãã‚Œã¯å›ã‚’å°ãã®ã‹ã€æƒ‘ã‚ã™ã®ã‹ï¼Ÿ\n\nå£°ã«æƒ‘ã‚ã•ã‚Œã¦ã¯ã„ã‘ãªã„...çœŸã®æ•µã‚’è¦‹æ¥µã‚ã‚ã€‚",
                        complete: "å£°ã®æ­£ä½“ã«è¿‘ã¥ã„ã¦ã„ã‚‹...ãã—ã¦çœŸã®æˆ¦ã„ãŒå§‹ã¾ã£ãŸã€‚\nå›ã®å¿ƒã¯æºã‚‹ãŒãªã„ã€‚",
                        enemies: ["å¹½éœŠã‚¯ãƒ©ã‚²", "æ·±æµ·ã®ç•ªäºº", "éŸ³æ³¢ã‚µãƒ¡"]
                    },
                    5: {
                        title: "ç¬¬5ç« ï¼šæµ·åº•ç¥æ®¿",
                        intro: "å¤ã„æµ·åº•ç¥æ®¿ã®éºè·¡ã«è¾¿ã‚Šç€ã„ãŸã€‚\nç¥ç§˜çš„ãªåŠ›ãŒè¿·è·¯ã‚’å®ˆè­·ã—ã€å¤ä»£ã®å®ˆè­·ç£ãŒå¾©æ´»ã—ãŸã€‚\n\nç¥æ®¿ã®å®ˆè­·è€…ãŸã¡ã¯å®¹èµ¦ãªã„...",
                        complete: "ç¥æ®¿ã®ç§˜å¯†ã®ä¸€éƒ¨ã‚’è§£ãæ˜ã‹ã—ãŸã€‚\nã—ã‹ã—çœŸã®è©¦ç·´ã¯ã“ã‚Œã‹ã‚‰ã ã€‚",
                        enemies: ["çŸ³ã®å®ˆè­·è€…", "å¤ä»£ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³", "ç¥æ®¿ã®ç•ªå…µ"]
                    },
                    6: {
                        title: "ç¬¬6ç« ï¼šæµ·ç‹ã®è©¦ç·´",
                        intro: "æµ·ç‹ã‹ã‚‰ã®è©¦ç·´ãŒå§‹ã¾ã£ãŸã€‚\nã“ã‚Œã¾ã§ã®çµŒé¨“ãŒè©¦ã•ã‚Œã‚‹æ™‚ã ã€‚\n\næµ·ç‹ã®çœ·å±ãŸã¡ãŒå›ã‚’å¾…ã¡å—ã‘ã¦ã„ã‚‹...",
                        complete: "æµ·ç‹ã«èªã‚ã‚‰ã‚Œã¤ã¤ã‚ã‚‹...ã ãŒæœ€çµ‚è©¦ç·´ã¯ã¾ã å…ˆã ã€‚\nå›ã®åŠ›ã¯æµ·ç‹ãƒ¬ãƒ™ãƒ«ã«è¿‘ã¥ã„ã¦ã„ã‚‹ã€‚",
                        enemies: ["æµ·ç‹ã®é¨å£«", "ãƒªãƒ´ã‚¡ã‚¤ã‚¢ã‚µãƒ³", "ãƒˆãƒ©ã‚¤ãƒ‡ãƒ³ãƒˆãƒ»ã‚¬ãƒ¼ãƒ‰"]
                    },
                    7: {
                        title: "ç¬¬7ç« ï¼šåµã®è¿·å®®",
                        intro: "åµã®æµ·ã«æµ®ã‹ã¶è¿·å®®ã€‚\næ¿€æµã¨é›·é³´ã€ãã—ã¦åµã®ç²¾éœŠãŸã¡ãŒå›ã®è¡Œãæ‰‹ã‚’é˜»ã‚€ã€‚\n\né›·ã«æ‰“ãŸã‚Œã¬ã‚ˆã†æ³¨æ„ã—ã‚...æ•µã‚‚é›»æ’ƒã‚’æ”¾ã¤ã€‚",
                        complete: "åµã‚’ä¹—ã‚Šè¶Šãˆã€é›·ã®ç²¾éœŠãŸã¡ã‚’é®ã‚ãŸï¼\nå›ã®æ„å¿—ã¯åµã‚ˆã‚Šã‚‚å¼·ã„ã€‚",
                        enemies: ["é›·ã®ç²¾éœŠ", "åµã‚µãƒ¡", "é›»æ’ƒã‚¨ã‚¤"]
                    },
                    8: {
                        title: "ç¬¬8ç« ï¼šæ·±æ·µã®å¢ƒç•Œ",
                        intro: "å…‰ã‚‚å±Šã‹ã¬æ·±æ·µã®å¢ƒç•Œç·šã€‚\nã“ã“ã‹ã‚‰å…ˆã¯çœŸã®å‹‡è€…ã®ã¿ãŒé€²ã‚ã‚‹ã€‚\n\né—‡ã®æ€ªç‰©ãŸã¡ãŒæ½œã‚“ã§ã„ã‚‹...å…‰ã‚’å¤±ã†ãªã€‚",
                        complete: "æ·±æ·µã‚’è¶ŠãˆãŸè€…ã‚ˆ...å›ã¯é¸ã°ã‚Œã—è€…ãªã®ã‹ï¼Ÿ\né—‡ã®åŠ›ã™ã‚‰å›ã®ã‚‚ã®ã¨ãªã£ãŸã€‚",
                        enemies: ["æ·±æ·µã®é­”ç‰©", "é—‡ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³", "è™šç„¡ã‚µãƒ¡"]
                    },
                    9: {
                        title: "ç¬¬9ç« ï¼šæœ€å¾Œã®å®ˆè­·è€…",
                        intro: "æœ€å¾Œã®å®ˆè­·è€…ãŒç«‹ã¡ã¯ã ã‹ã‚‹ã€‚\nå…¨ã¦ã®çŸ¥è­˜ã¨å‹‡æ°—ã‚’çµé›†ã›ã‚ˆã€‚\n\nä¼èª¬ã®æµ·ç£ãŸã¡ã¨ã®æœ€çµ‚æ±ºæˆ¦ãŒå§‹ã¾ã‚‹...",
                        complete: "å®ˆè­·è€…ã‚’è¶ŠãˆãŸ...ã¤ã„ã«æœ€çµ‚ã®æ‰‰ãŒè¦‹ãˆã¦ããŸã€‚\nå›ã¯ä¼èª¬ã®æˆ¦å£«ã¨ãªã£ãŸã€‚",
                        enemies: ["æœ€çµ‚å®ˆè­·è€…", "æµ·ã®é¾ç‹", "ã‚¢ãƒ“ã‚¹ãƒ»ãƒªãƒ´ã‚¡ã‚¤ã‚¢ã‚µãƒ³"]
                    },
                    10: {
                        title: "ç¬¬10ç« ï¼šæµ·å­¦ã®çœŸç†",
                        intro: "ã¤ã„ã«æœ€çµ‚å±¤ã«åˆ°é”ã—ãŸã€‚\næµ·å­¦ã®çœŸç†ãŒã“ã“ã«çœ ã£ã¦ã„ã‚‹ã€‚\n\næœ€å¾Œã®æ•µã¯...å›è‡ªèº«ã®ææ€–ã ã€‚ãã‚Œã‚’ä¹—ã‚Šè¶Šãˆã‚ã€‚\n\nå…¨ã¦ã®åŠ›ã‚’çµé›†ã—ã€çœŸã®æµ·å­¦ãƒã‚¹ã‚¿ãƒ¼ã¨ãªã‚Œï¼",
                        complete: "ğŸ‰ ãŠã‚ã§ã¨ã†ï¼å›ã¯çœŸã®æµ·å­¦ãƒã‚¹ã‚¿ãƒ¼ã¨ãªã£ãŸï¼ ğŸ‰\n\næ·±æµ·ã®å…¨ã¦ã®ç§˜å¯†ã‚’è§£ãæ˜ã‹ã—ã€ã™ã¹ã¦ã®æ•µã‚’æ‰“ã¡å€’ã—ã€\nçœŸã®å‹‡è€…ã¨ã—ã¦ä¼èª¬ã¨ãªã£ãŸã®ã ã€‚\n\næµ·ã®ç¥ã€…ã‚‚å›ã®å‹‡æ°—ã‚’è®ƒãˆã¦ã„ã‚‹...",
                        enemies: ["æµ·å­¦ã®åŒ–èº«", "æ·±æµ·çš‡å¸", "çœŸç†ã®ç•ªäºº", "æµ·ç¥ã®ä½¿è€…"]
                    }
                };
            }
            
            detectMobile() {
                const userAgent = navigator.userAgent;
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent) || 
                       'ontouchstart' in window ||
                       window.innerWidth <= 768;
            }
            
            showMobileWarning() {
                const mobileWarning = document.getElementById('mobileWarning');
                if (mobileWarning) {
                    mobileWarning.style.display = 'flex';
                }
            }
            
            returnToWebsite() {
                if (confirm('ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¦ã‚µã‚¤ãƒˆã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ')) {
                    window.location.href = '/games/';
                }
            }
            
            quitGame() {
                if (confirm('ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿé€²è¡ŒçŠ¶æ³ã¯å¤±ã‚ã‚Œã¾ã™ã€‚')) {
                    this.isGameOver = true;
                    this.gameStarted = false;
                    document.exitPointerLock();
                    window.location.href = '/games/';
                }
            }
            

            init() {
                console.log('Initializing game...');
                
                // ãƒ¢ãƒã‚¤ãƒ«ç«¯æœ«ã®å ´åˆã¯è­¦å‘Šè¡¨ç¤º
                if (this.isMobile) {
                    this.showMobileWarning();
                    return;
                }
                
                this.setupScene();
                this.generateComplexMaze();
                this.createMaze3D();
                this.setupEventListeners();
                this.initMinimap();
                
                // å¼·åˆ¶çš„ã«canvasã‚µã‚¤ã‚ºã‚’ä¿®æ­£
                this.forceCanvasResize();
                
                this.animate();
                
                // ã‚²ãƒ¼ãƒ é–‹å§‹æº–å‚™å®Œäº†
                this.gameStarted = false;
                this.startTime = Date.now();
                
                console.log('Game initialized');
            }
            
            forceCanvasResize() {
                const canvas = document.getElementById('canvas');
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                // canvasã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’è¨­å®š
                canvas.width = width;
                canvas.height = height;
                
                // ã‚¹ã‚¿ã‚¤ãƒ«ã‚‚å¼·åˆ¶è¨­å®š
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                canvas.style.position = 'fixed';
                canvas.style.top = '0px';
                canvas.style.left = '0px';
                canvas.style.zIndex = '1';
                
                // Three.jsãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã‚‚æ›´æ–°
                this.renderer.setSize(width, height, false);
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                
                console.log('Canvas forced to size:', width, 'x', height);
            }
            
            initMinimap() {
                this.minimapCanvas = document.getElementById('minimapCanvas');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                
                // æ¢ç´¢ãƒãƒƒãƒ—ã‚’åˆæœŸåŒ–ï¼ˆæœ€åˆã¯å…¨ã¦æœªæ¢ç´¢ï¼‰
                this.exploredMap = [];
                for (let y = 0; y < this.mazeSize; y++) {
                    this.exploredMap[y] = [];
                    for (let x = 0; x < this.mazeSize; x++) {
                        this.exploredMap[y][x] = false;
                    }
                }
                
                console.log('Minimap initialized');
            }
            
            updateMinimap() {
                if (!this.minimapCtx) return;
                
                const ctx = this.minimapCtx;
                const size = 150;
                const cellSize = size / this.mazeSize;
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®
                const playerX = Math.floor(this.camera.position.x / this.cellSize);
                const playerZ = Math.floor(this.camera.position.z / this.cellSize);
                
                // ç¾åœ¨ä½ç½®ã¨ãã®å‘¨è¾ºã‚’æ¢ç´¢æ¸ˆã¿ã«ãƒãƒ¼ã‚¯ï¼ˆè¦–ç·šæ–¹å‘ã‚’è€ƒæ…®ï¼‰
                this.exploredMap[playerZ][playerX] = true; // ç¾åœ¨ä½ç½®ã¯å¿…ãšæ¢ç´¢æ¸ˆã¿
                
                // éš£æ¥ã™ã‚‹ã‚»ãƒ«ã®ã¿æ¢ç´¢ï¼ˆ4æ–¹å‘ã®ã¿ï¼‰
                const adjacentCells = [
                    {x: playerX + 1, z: playerZ},     // å³
                    {x: playerX - 1, z: playerZ},     // å·¦
                    {x: playerX, z: playerZ + 1},     // ä¸‹
                    {x: playerX, z: playerZ - 1}      // ä¸Š
                ];
                
                for (const cell of adjacentCells) {
                    if (cell.x >= 0 && cell.x < this.mazeSize && 
                        cell.z >= 0 && cell.z < this.mazeSize) {
                        this.exploredMap[cell.z][cell.x] = true;
                    }
                }
                
                // ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’æç”»
                ctx.clearRect(0, 0, size, size);
                
                // è¿·è·¯ã‚’æç”»
                for (let y = 0; y < this.mazeSize; y++) {
                    for (let x = 0; x < this.mazeSize; x++) {
                        const drawX = x * cellSize;
                        const drawY = y * cellSize;
                        
                        if (this.exploredMap[y][x]) {
                            if (this.maze[y][x] === 1) {
                                // å£ï¼ˆæ¢ç´¢æ¸ˆã¿ï¼‰
                                ctx.fillStyle = '#444444';
                            } else {
                                // é€šè·¯ï¼ˆæ¢ç´¢æ¸ˆã¿ï¼‰
                                ctx.fillStyle = '#888888';
                            }
                        } else {
                            // æœªæ¢ç´¢ã‚¨ãƒªã‚¢
                            ctx.fillStyle = '#000000';
                        }
                        
                        ctx.fillRect(drawX, drawY, cellSize, cellSize);
                    }
                }
                
                // ã‚´ãƒ¼ãƒ«ã‚’æç”»ï¼ˆæ¢ç´¢æ¸ˆã¿ã®å ´åˆï¼‰
                const goalX = this.mazeSize - 2;
                const goalZ = this.mazeSize - 2;
                if (this.exploredMap[goalZ][goalX]) {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(goalX * cellSize, goalZ * cellSize, cellSize, cellSize);
                }
                
                // æ•µã‚’æç”»ï¼ˆè¦–ç•Œå†…ã®å ´åˆï¼‰
                ctx.fillStyle = '#ff6666';
                for (const enemy of this.enemies) {
                    if (!enemy.userData.alive) continue;
                    
                    const enemyX = Math.floor(enemy.position.x / this.cellSize);
                    const enemyZ = Math.floor(enemy.position.z / this.cellSize);
                    
                    if (enemyX >= 0 && enemyX < this.mazeSize && 
                        enemyZ >= 0 && enemyZ < this.mazeSize &&
                        this.exploredMap[enemyZ][enemyX]) {
                        
                        const distance = Math.sqrt(
                            Math.pow(enemyX - playerX, 2) + Math.pow(enemyZ - playerZ, 2)
                        );
                        
                        if (distance <= 2) { // è¦–ç•Œå†…ï¼ˆç¸®å°ï¼‰
                            ctx.beginPath();
                            ctx.arc(
                                enemyX * cellSize + cellSize/2, 
                                enemyZ * cellSize + cellSize/2, 
                                cellSize/3, 0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                    }
                }
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æç”»ï¼ˆæ–¹å‘ä»˜ãï¼‰
                if (playerX >= 0 && playerX < this.mazeSize && 
                    playerZ >= 0 && playerZ < this.mazeSize) {
                    
                    const centerX = playerX * cellSize + cellSize/2;
                    const centerY = playerZ * cellSize + cellSize/2;
                    
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æœ¬ä½“
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, cellSize/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // æ–¹å‘æŒ‡ç¤ºç·šï¼ˆæ­£ã—ã„æ–¹å‘ï¼‰
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    const dirLength = cellSize/2;
                    
                    // Three.jsã‚«ãƒ¡ãƒ©ã®å‘ãã‚’æ­£ç¢ºã«å–å¾—
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyQuaternion(this.camera.quaternion);
                    
                    ctx.lineTo(
                        centerX + direction.x * dirLength,
                        centerY + direction.z * dirLength  // ZãŒå‰å¾Œã€Yã¯ä¸Šä¸‹ãªã®ã§Zã‚’ä½¿ç”¨
                    );
                    ctx.stroke();
                }
            }
            
            updateCompass() {
                // ã‚«ãƒ¡ãƒ©ã®ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‹ã‚‰æ­£ç¢ºãªæ–¹å‘ã‚’å–å¾—
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                
                // Yè»¸å‘¨ã‚Šã®å›è»¢è§’åº¦ã‚’è¨ˆç®—ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
                const angle = Math.atan2(direction.x, -direction.z);
                this.playerDirection = angle;
                
                // åº¦æ•°ã«å¤‰æ›ã—ã¦æ–¹ä½ã‚’æ±ºå®š
                const degrees = ((angle * 180 / Math.PI) + 360) % 360;
                let compassDirection = '';
                
                if (degrees >= 337.5 || degrees < 22.5) compassDirection = 'åŒ—';
                else if (degrees >= 22.5 && degrees < 67.5) compassDirection = 'åŒ—æ±';
                else if (degrees >= 67.5 && degrees < 112.5) compassDirection = 'æ±';
                else if (degrees >= 112.5 && degrees < 157.5) compassDirection = 'å—æ±';
                else if (degrees >= 157.5 && degrees < 202.5) compassDirection = 'å—';
                else if (degrees >= 202.5 && degrees < 247.5) compassDirection = 'å—è¥¿';
                else if (degrees >= 247.5 && degrees < 292.5) compassDirection = 'è¥¿';
                else if (degrees >= 292.5 && degrees < 337.5) compassDirection = 'åŒ—è¥¿';
                
                document.getElementById('compass').textContent = compassDirection;
            }
            
            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x001a33); // ã‚ˆã‚Šæ·±ã„æµ·ã®è‰²
                this.scene.fog = new THREE.Fog(0x001a33, 5, 25); // æµ·ä¸­ã®éœ§åŠ¹æœ
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(6, 2, 6); // è¿·è·¯å†…éƒ¨ã®ç¢ºå®Ÿã«é€šè·¯ã®ä½ç½®
                console.log('Camera start position:', this.camera.position);
                
                // Renderer
                const canvas = document.getElementById('canvas');
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                
                // ãƒ‡ãƒã‚¤ã‚¹ãƒ”ã‚¯ã‚»ãƒ«æ¯”ã‚’è€ƒæ…®ã—ãŸã‚µã‚¤ã‚ºè¨­å®š
                const pixelRatio = Math.min(window.devicePixelRatio, 2);
                this.renderer.setPixelRatio(pixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight, false);
                
                // canvasã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚‚æ˜ç¤ºçš„ã«è¨­å®š
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.display = 'block';
                
                // æµ·ä¸­ã®ç…§æ˜
                const ambientLight = new THREE.AmbientLight(0x002244, 0.4); // é’ã£ã½ã„ç’°å¢ƒå…‰
                this.scene.add(ambientLight);
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ©ã‚¤ãƒˆï¼ˆæ½œæ°´ãƒ©ã‚¤ãƒˆé¢¨ï¼‰
                const playerLight = new THREE.SpotLight(0xffffff, 1, 20, Math.PI / 6, 0.3);
                playerLight.position.copy(this.camera.position);
                playerLight.target.position.set(0, 0, -1);
                this.scene.add(playerLight);
                this.scene.add(playerLight.target);
                this.playerLight = playerLight;
                
                // æµ·ä¸­ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœ
                this.createOceanParticles();
                
                console.log('Ocean scene setup complete');
            }
            
            createOceanParticles() {
                // æµ·ä¸­ã®æµ®éŠç‰©ï¼ˆãƒ—ãƒ©ãƒ³ã‚¯ãƒˆãƒ³ã€æ³¡ãªã©ï¼‰
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 100;     // x
                    positions[i + 1] = Math.random() * 20;          // y
                    positions[i + 2] = (Math.random() - 0.5) * 100; // z
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: 0x4499ff,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }
            
            generateComplexMaze() {
                // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸã‚µã‚¤ã‚ºã¨é›£æ˜“åº¦
                this.setLevelDifficulty();
                
                // ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ç´¹ä»‹ã‚’è¡¨ç¤º
                this.showStoryIntro();
                
                // è¿·è·¯ç”Ÿæˆ
                this.maze = [];
                
                // å…¨ã¦å£ã§åˆæœŸåŒ–
                for (let i = 0; i < this.mazeSize; i++) {
                    this.maze[i] = [];
                    for (let j = 0; j < this.mazeSize; j++) {
                        this.maze[i][j] = 1; // å£
                    }
                }
                
                // å†å¸°ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯æ³•ã§è¿·è·¯ç”Ÿæˆ
                this.visited = [];
                for (let i = 0; i < this.mazeSize; i++) {
                    this.visited[i] = [];
                    for (let j = 0; j < this.mazeSize; j++) {
                        this.visited[i][j] = false;
                    }
                }
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã‹ã‚‰è¿·è·¯ã‚’æ˜ã‚‹
                this.carveMaze(1, 1);
                
                // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸè¿½åŠ ã®è¤‡é›‘ã•
                this.addLevelComplexity();
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆã¨ã‚´ãƒ¼ãƒ«ã‚’ç¢ºå®Ÿã«é€šè·¯ã«ã™ã‚‹
                this.maze[1][1] = 0; // ã‚¹ã‚¿ãƒ¼ãƒˆ
                this.maze[this.mazeSize - 2][this.mazeSize - 2] = 0; // ã‚´ãƒ¼ãƒ«
                
                console.log(`Level ${this.currentLevel} maze generated (${this.mazeSize}x${this.mazeSize})`);
            }
            
            setLevelDifficulty() {
                // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ã‚µã‚¤ã‚ºã¨è¨­å®šã‚’å¤‰æ›´
                if (this.currentLevel <= 2) {
                    this.mazeSize = 11; // åˆç´š
                    this.moveSpeed = 0.12;
                } else if (this.currentLevel <= 4) {
                    this.mazeSize = 15; // ä¸­ç´š
                    this.moveSpeed = 0.10;
                } else if (this.currentLevel <= 6) {
                    this.mazeSize = 19; // ä¸Šç´š
                    this.moveSpeed = 0.08;
                } else if (this.currentLevel <= 8) {
                    this.mazeSize = 23; // è¶…ç´š
                    this.moveSpeed = 0.07;
                } else {
                    this.mazeSize = 27; // ç¥ç´šï¼ˆæœ€çµ‚ç« ï¼‰
                    this.moveSpeed = 0.06;
                }
                
                console.log(`Level ${this.currentLevel} difficulty: maze size ${this.mazeSize}, speed ${this.moveSpeed}`);
            }
            
            addLevelComplexity() {
                // ãƒ¬ãƒ™ãƒ«ãŒé«˜ã„ã»ã©è¤‡é›‘ãªä»•æ›ã‘ã‚’è¿½åŠ 
                if (this.currentLevel >= 3) {
                    // ãƒ‡ãƒƒãƒ‰ã‚¨ãƒ³ãƒ‰ã‚’å¢—ã‚„ã™
                    this.addDeadEnds();
                }
                
                if (this.currentLevel >= 5) {
                    // ãƒ«ãƒ¼ãƒ—ã‚’ä½œã£ã¦æ··ä¹±ã•ã›ã‚‹
                    this.addLoops();
                }
                
                if (this.currentLevel >= 7) {
                    // å½ã®ã‚´ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ã‚’è¿½åŠ 
                    this.addFakeGoalAreas();
                }
            }
            
            addDeadEnds() {
                const deadEndCount = Math.floor(this.currentLevel * 1.5);
                for (let i = 0; i < deadEndCount; i++) {
                    const x = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    const y = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    if (this.maze[y][x] === 0) {
                        // ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘ã«çŸ­ã„è¡Œãæ­¢ã¾ã‚Šã‚’ä½œã‚‹
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        const dir = directions[Math.floor(Math.random() * directions.length)];
                        const newX = x + dir[0] * 2;
                        const newY = y + dir[1] * 2;
                        if (newX > 0 && newX < this.mazeSize - 1 && newY > 0 && newY < this.mazeSize - 1) {
                            this.maze[y + dir[1]][x + dir[0]] = 0;
                            this.maze[newY][newX] = 0;
                        }
                    }
                }
            }
            
            addLoops() {
                const loopCount = Math.floor(this.currentLevel * 0.8);
                for (let i = 0; i < loopCount; i++) {
                    const x = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    const y = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    if (this.maze[y][x] === 1) {
                        // éš£æ¥ã™ã‚‹é€šè·¯ãŒ2ã¤ä»¥ä¸Šã‚ã‚Œã°å£ã‚’å‰Šé™¤ã—ã¦ãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚‹
                        let adjacentPaths = 0;
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        for (const [dx, dy] of directions) {
                            if (this.maze[y + dy] && this.maze[y + dy][x + dx] === 0) {
                                adjacentPaths++;
                            }
                        }
                        if (adjacentPaths >= 2) {
                            this.maze[y][x] = 0;
                        }
                    }
                }
            }
            
            addFakeGoalAreas() {
                // å½ã®ã‚´ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ã‚’æ•°ç®‡æ‰€ã«é…ç½®
                const fakeGoals = Math.min(3, Math.floor(this.currentLevel * 0.5));
                for (let i = 0; i < fakeGoals; i++) {
                    const x = Math.floor(Math.random() * (this.mazeSize - 6)) + 3;
                    const y = Math.floor(Math.random() * (this.mazeSize - 6)) + 3;
                    // 3x3ã®å°ã•ãªã‚¨ãƒªã‚¢ã‚’ä½œã‚‹
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (x + dx > 0 && x + dx < this.mazeSize - 1 && 
                                y + dy > 0 && y + dy < this.mazeSize - 1) {
                                this.maze[y + dy][x + dx] = 0;
                            }
                        }
                    }
                }
            }
            
            carveMaze(x, y) {
                this.visited[y][x] = true;
                this.maze[y][x] = 0; // é€šè·¯ã«ã™ã‚‹
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘é †åº
                const directions = [
                    [0, -2], [2, 0], [0, 2], [-2, 0] // ä¸Šã€å³ã€ä¸‹ã€å·¦
                ].sort(() => Math.random() - 0.5);
                
                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    // å¢ƒç•Œå†…ã‹ã¤æœªè¨ªå•ã®å ´åˆ
                    if (newX > 0 && newX < this.mazeSize - 1 && 
                        newY > 0 && newY < this.mazeSize - 1 && 
                        !this.visited[newY][newX]) {
                        
                        // é–“ã®å£ã‚’å‰Šé™¤
                        this.maze[y + dy/2][x + dx/2] = 0;
                        this.carveMaze(newX, newY);
                    }
                }
            }
            
            createMaze3D() {
                const CELL = this.cellSize;
                const wallHeight = this.wallHeight;
                
                // å£ç·šã®ãƒãƒ†ãƒªã‚¢ãƒ«
                const wallMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
                
                // å„ã‚»ãƒ«ã®å£ç·šã‚’ç”Ÿæˆ
                for (let cz = 0; cz < this.mazeSize; cz++) {
                    for (let cx = 0; cx < this.mazeSize; cx++) {
                        if (this.maze[cz][cx] === 1) {
                            // ã‚»ãƒ« (cx, cz) ãŒå£ã®å ´åˆã€å„è¾ºã«ç·šã‚’æç”»
                            this.createWallLines(cx, cz, CELL, wallHeight, wallMaterial);
                        }
                    }
                }
                
                // ã‚´ãƒ¼ãƒ«ã‚’ä½œæˆï¼ˆãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
                this.createGoal();
                
                // æ•µã‚’é…ç½®
                this.spawnEnemies();
                
                console.log('3D maze created with wall lines and enemies');
            }
            
            createWallLines(cx, cz, CELL, wallHeight, material) {
                const x = cx * CELL;
                const z = cz * CELL;
                
                // åŒ—å£ (zå´)
                this.addWallLine(
                    [x, 0, z, (x + CELL), 0, z, x, wallHeight, z, (x + CELL), wallHeight, z],
                    material
                );
                
                // æ±å£ (x+1å´)  
                this.addWallLine(
                    [(x + CELL), 0, z, (x + CELL), 0, (z + CELL), (x + CELL), wallHeight, z, (x + CELL), wallHeight, (z + CELL)],
                    material
                );
                
                // å—å£ (z+1å´)
                this.addWallLine(
                    [x, 0, (z + CELL), (x + CELL), 0, (z + CELL), x, wallHeight, (z + CELL), (x + CELL), wallHeight, (z + CELL)],
                    material
                );
                
                // è¥¿å£ (xå´)
                this.addWallLine(
                    [x, 0, z, x, 0, (z + CELL), x, wallHeight, z, x, wallHeight, (z + CELL)],
                    material
                );
            }
            
            addWallLine(points, material) {
                const geometry = new THREE.BufferGeometry();
                const vertices = new Float32Array(points);
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                
                // ç·šã®æç”»é †åºï¼ˆåº•è¾ºâ†’ä¸Šè¾ºâ†’ç¸¦ç·šï¼‰
                const indices = [
                    0, 1,  // åº•è¾º
                    2, 3,  // ä¸Šè¾º
                    0, 2,  // å·¦ç¸¦ç·š
                    1, 3   // å³ç¸¦ç·š
                ];
                geometry.setIndex(indices);
                
                const line = new THREE.LineSegments(geometry, material);
                this.scene.add(line);
            }
            
            createGoal() {
                const goalGeometry = new THREE.BoxGeometry(2, 2, 2);
                const goalEdges = new THREE.EdgesGeometry(goalGeometry);
                const goalMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xff0000
                });
                
                this.goal = new THREE.LineSegments(goalEdges, goalMaterial);
                this.goal.position.set((this.mazeSize - 2) * this.cellSize, 1, (this.mazeSize - 2) * this.cellSize);
                this.scene.add(this.goal);
                
                // ã‚´ãƒ¼ãƒ«ã®å…‰ã‚‹åŠ¹æœ
                const goalLight = new THREE.PointLight(0xff0000, 1, 10);
                goalLight.position.copy(this.goal.position);
                this.scene.add(goalLight);
            }
            
            
            spawnEnemies() {
                this.enemies = [];
                const enemyCount = Math.min(3 + this.currentLevel, 8); // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦æ•µã®æ•°ã‚’å¢—åŠ 
                
                for (let i = 0; i < enemyCount; i++) {
                    this.createEnemy();
                }
            }
            
            createEnemy() {
                // æ•µã®3Dãƒ¢ãƒ‡ãƒ«ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªæµ·ç£ï¼‰
                const enemyGroup = new THREE.Group();
                
                // ä½“ï¼ˆãƒ¡ã‚¤ãƒ³ï¼‰
                const bodyGeometry = new THREE.SphereGeometry(0.8, 8, 6);
                const bodyMaterial = new THREE.MeshBasicMaterial({ 
                    color: this.getEnemyColor(),
                    wireframe: true 
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                enemyGroup.add(body);
                
                // è§¦æ‰‹ã‚„é°­ï¼ˆè£…é£¾ï¼‰
                for (let i = 0; i < 4; i++) {
                    const tentacleGeometry = new THREE.CylinderGeometry(0.1, 0.05, 1);
                    const tentacleMaterial = new THREE.MeshBasicMaterial({ 
                        color: this.getEnemyColor(),
                        wireframe: true 
                    });
                    const tentacle = new THREE.Mesh(tentacleGeometry, tentacleMaterial);
                    tentacle.position.set(
                        Math.cos(i * Math.PI / 2) * 0.6,
                        -0.5,
                        Math.sin(i * Math.PI / 2) * 0.6
                    );
                    tentacle.rotation.z = Math.PI / 6;
                    enemyGroup.add(tentacle);
                }
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«é…ç½®ï¼ˆé€šè·¯ã®ã¿ï¼‰
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 50) {
                    const x = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    const z = Math.floor(Math.random() * (this.mazeSize - 4)) + 2;
                    
                    if (this.maze[z][x] === 0) { // é€šè·¯ã®å ´åˆ
                        enemyGroup.position.set(x * this.cellSize, 1, z * this.cellSize);
                        placed = true;
                    }
                    attempts++;
                }
                
                if (placed) {
                    // æ•µã®å±æ€§
                    enemyGroup.userData = {
                        hp: 20 + this.currentLevel * 5,
                        maxHP: 20 + this.currentLevel * 5,
                        damage: 10 + this.currentLevel * 2,
                        speed: 0.03 + this.currentLevel * 0.008,
                        lastAttackTime: 0,
                        attackCooldown: 1500 - this.currentLevel * 100, // ãƒ¬ãƒ™ãƒ«ãŒä¸ŠãŒã‚‹ã¨æ”»æ’ƒé »åº¦å¢—åŠ 
                        alive: true,
                        mode: 'patrol',
                        alertTime: 0,
                        animOffset: Math.random() * Math.PI * 2,
                        patrolTarget: null,
                        lastPatrolTime: 0,
                        aggressionLevel: Math.min(1.0, this.currentLevel * 0.1) // æ”»æ’ƒæ€§
                    };
                    
                    this.scene.add(enemyGroup);
                    this.enemies.push(enemyGroup);
                }
            }
            
            getEnemyColor() {
                const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            setupEventListeners() {
                const canvas = document.getElementById('canvas');
                
                // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ
                document.addEventListener('keydown', (event) => {
                    console.log('Key pressed:', event.code);
                    this.keys[event.code] = true;
                    
                    // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§æ”»æ’ƒ
                    if (event.code === 'Space' && this.gameStarted) {
                        event.preventDefault(); // ãƒšãƒ¼ã‚¸ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã
                        this.performAttack();
                    }
                    
                });
                
                document.addEventListener('keyup', (event) => {
                    console.log('Key released:', event.code);
                    this.keys[event.code] = false;
                });
                
                // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
                canvas.addEventListener('click', () => {
                    if (!this.pointerLocked) {
                        canvas.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.pointerLocked = document.pointerLockElement === canvas;
                    console.log('Pointer lock changed:', this.pointerLocked);
                    
                    // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯è§£é™¤é€šçŸ¥
                    const notification = document.getElementById('pointerLockNotification');
                    if (!this.pointerLocked && this.gameStarted && notification) {
                        notification.style.display = 'block';
                        // 3ç§’å¾Œã«è‡ªå‹•ã§éè¡¨ç¤º
                        setTimeout(() => {
                            notification.style.display = 'none';
                        }, 3000);
                    } else if (this.pointerLocked && notification) {
                        notification.style.display = 'none';
                    }
                });
                
                document.addEventListener('mousemove', (event) => {
                    if (this.pointerLocked && this.gameStarted) {
                        const movementX = event.movementX || 0;
                        const movementY = event.movementY || 0;
                        
                        console.log('Mouse movement:', { x: movementX, y: movementY, locked: this.pointerLocked, started: this.gameStarted });
                        
                        this.rotationY -= movementX * 0.002;
                        this.rotationX -= movementY * 0.002;
                        this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));
                        
                        // Eulerè§’ã§ã®å›è»¢è¨­å®š
                        const euler = new THREE.Euler(this.rotationX, this.rotationY, 0, 'YXZ');
                        this.camera.quaternion.setFromEuler(euler);
                        
                        console.log('Camera rotation updated:', { x: this.rotationX, y: this.rotationY });
                    } else {
                        console.log('Mouse movement ignored - locked:', this.pointerLocked, 'started:', this.gameStarted);
                    }
                });
                
                // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚º
                window.addEventListener('resize', () => {
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    
                    this.renderer.setSize(width, height, false);
                    
                    // canvasã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚‚æ›´æ–°
                    const canvas = document.getElementById('canvas');
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    
                    console.log('Resized to:', width, 'x', height);
                });
                
                console.log('Event listeners setup complete');
            }
            
            
            updateMovement() {
                if (!this.gameStarted) {
                    console.log('Movement blocked - game not started');
                    return;
                }
                
                // ã‚«ãƒ¡ãƒ©ã®å‘ã„ã¦ã„ã‚‹æ–¹å‘ã‚’å–å¾—
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                
                // å³æ–¹å‘ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(this.camera.quaternion);
                
                // Yæˆåˆ†ã‚’0ã«ã—ã¦æ°´å¹³ç§»å‹•ã®ã¿ã«ã™ã‚‹
                direction.y = 0;
                right.y = 0;
                direction.normalize();
                right.normalize();
                
                // ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                let dx = 0;
                let dz = 0;
                
                if (this.keys['KeyW']) {
                    dx += direction.x * this.moveSpeed;
                    dz += direction.z * this.moveSpeed;
                }
                if (this.keys['KeyS']) {
                    dx -= direction.x * this.moveSpeed;
                    dz -= direction.z * this.moveSpeed;
                }
                if (this.keys['KeyA']) {
                    dx -= right.x * this.moveSpeed;
                    dz -= right.z * this.moveSpeed;
                }
                if (this.keys['KeyD']) {
                    dx += right.x * this.moveSpeed;
                    dz += right.z * this.moveSpeed;
                }
                
                // ãƒ—ãƒ­ä»•æ§˜ã®è¡çªåˆ¤å®šä»˜ãç§»å‹•
                this.movePlayer(dx, dz, 1.0);
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ©ã‚¤ãƒˆã‚’è¿½å¾“ã•ã›ã‚‹
                this.playerLight.position.copy(this.camera.position);
                const lightDirection = new THREE.Vector3(0, 0, -1);
                lightDirection.applyQuaternion(this.camera.quaternion);
                this.playerLight.target.position.copy(this.camera.position).add(lightDirection.multiplyScalar(5));
                
                this.updateHUD();
            }
            
            movePlayer(dx, dz, delta) {
                const playerR = 0.3; // æ¨™æº–çš„ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŠå¾„ã«æˆ»ã™
                const CELL = this.cellSize;
                
                // ç¾åœ¨ä½ç½®
                const pos = this.camera.position;
                const currentPos = { x: pos.x, z: pos.z };
                
                // ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã®é•·ã•
                const moveLen = Math.sqrt(dx * dx + dz * dz);
                if (moveLen === 0) return;
                
                // æ®µéšçš„ç§»å‹•ï¼ˆå°ã•ãªã‚¹ãƒ†ãƒƒãƒ—ã§å®‰å…¨ã«ï¼‰
                const steps = Math.ceil(moveLen / 0.05); // 0.05å˜ä½ã§ç§»å‹•
                const stepX = dx / steps;
                const stepZ = dz / steps;
                
                for (let i = 0; i < steps; i++) {
                    const nextX = pos.x + stepX;
                    const nextZ = pos.z + stepZ;
                    const nextPos = { x: nextX, z: nextZ };
                    
                    // ç§»å‹•å…ˆãŒå®‰å…¨ã‹ãƒã‚§ãƒƒã‚¯
                    if (this.isSafePosition(nextPos, playerR, CELL)) {
                        pos.x = nextX;
                        pos.z = nextZ;
                    } else {
                        // ç§»å‹•ã§ããªã„å ´åˆã¯ã“ã“ã§åœæ­¢
                        break;
                    }
                }
            }
            
            isSafePosition(p, playerR, CELL) {
                // ã‚ˆã‚Šä¿å®ˆçš„ã§ç¢ºå®Ÿãªå®‰å…¨åˆ¤å®š
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å††å½¢ç¯„å›²ã‚’ç´°ã‹ããƒã‚§ãƒƒã‚¯
                const checkPoints = [];
                const numPoints = 12; // å††å‘¨ä¸Šã®12ç‚¹
                
                // ä¸­å¿ƒç‚¹
                checkPoints.push({ x: p.x, z: p.z });
                
                // å††å‘¨ä¸Šã®ç‚¹ã€…
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    checkPoints.push({
                        x: p.x + Math.cos(angle) * playerR,
                        z: p.z + Math.sin(angle) * playerR
                    });
                }
                
                // å„ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãŒå®‰å…¨ã‹ã©ã†ã‹
                for (const point of checkPoints) {
                    const cellX = Math.floor(point.x / CELL);
                    const cellZ = Math.floor(point.z / CELL);
                    
                    // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
                    if (cellX < 0 || cellX >= this.mazeSize || cellZ < 0 || cellZ >= this.mazeSize) {
                        return false;
                    }
                    
                    // å£ãƒã‚§ãƒƒã‚¯
                    if (this.maze[cellZ][cellX] === 1) {
                        return false;
                    }
                }
                
                return true;
            }
            
            isBlocked(p, playerR, CELL) {
                return !this.isSafePosition(p, playerR, CELL);
            }
            
            
            updateHUD() {
                const gridX = Math.floor(this.camera.position.x / this.cellSize);
                const gridZ = Math.floor(this.camera.position.z / this.cellSize);
                
                document.getElementById('currentLevel').textContent = this.currentLevel;
                document.getElementById('maxLevel').textContent = this.maxLevel;
                document.getElementById('playerHP').textContent = this.playerHP;
                document.getElementById('maxHP').textContent = this.maxHP;
                
                // æ–°ã—ã„HUDè¦ç´ ã‚’æ›´æ–°
                document.getElementById('playerLevel').textContent = this.playerLevel;
                document.getElementById('experience').textContent = this.experience;
                document.getElementById('experienceToNext').textContent = this.experienceToNext;
                document.getElementById('magicPower').textContent = this.magicPower;
                document.getElementById('combo').textContent = this.combo;
                document.getElementById('score').textContent = this.score;
                
                // HPãƒãƒ¼ã®è‰²å¤‰æ›´
                const hpElement = document.getElementById('playerHP');
                if (this.playerHP < this.maxHP * 0.3) {
                    hpElement.style.color = '#ff4444';
                } else if (this.playerHP < this.maxHP * 0.6) {
                    hpElement.style.color = '#ffaa44';
                } else {
                    hpElement.style.color = '#ffffff';
                }
                
                // ã‚³ãƒ³ãƒœã‚¿ã‚¤ãƒãƒ¼
                if (this.combo > 0 && Date.now() - this.comboTime > 3000) {
                    this.combo = 0;
                }
                
                // ã‚´ãƒ¼ãƒ«åˆ¤å®š
                if (this.goal) {
                    const distance = this.camera.position.distanceTo(this.goal.position);
                    if (distance < 3) {
                        this.gameWin();
                    }
                }
            }
            

            performAttack() {
                const currentTime = Date.now();
                if (currentTime - this.attackCooldown < 500) return; // æ”»æ’ƒã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
                
                this.attackCooldown = currentTime;
                this.isAttacking = true;
                
                this.performMagicAttack();
            }
            
            
            performMagicAttack() {
                // é­”æ³•å¼¾ã‚’ç™ºå°„
                const playerPos = this.camera.position.clone();
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                
                const projectile = this.createMagicProjectile(playerPos, direction);
                this.magicProjectiles.push(projectile);
                this.scene.add(projectile);
                
                this.isAttacking = false;
            }
            
            createMagicProjectile(startPos, direction) {
                // é­”æ³•å¼¾ã®è¦‹ãŸç›®
                const geometry = new THREE.SphereGeometry(0.2, 8, 6);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                const projectile = new THREE.Mesh(geometry, material);
                
                // å…‰ã‚‹åŠ¹æœ
                const glowGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x44ffff,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                projectile.add(glow);
                
                projectile.position.copy(startPos);
                // ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ’ãƒƒãƒˆåˆ¤å®š
                const isCritical = Math.random() < this.criticalChance;
                const baseDamage = this.magicPower + Math.floor(Math.random() * 10);
                const finalDamage = isCritical ? baseDamage * 2 : baseDamage;
                
                projectile.userData = {
                    direction: direction.clone(),
                    speed: 0.5,
                    damage: finalDamage,
                    isCritical: isCritical,
                    life: 100 // ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
                };
                
                // ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã®å ´åˆã¯è¦‹ãŸç›®ã‚’å¤‰æ›´
                if (isCritical) {
                    projectile.children[0].material.color.setHex(0xffd700); // ã‚´ãƒ¼ãƒ«ãƒ‰è‰²
                    projectile.scale.setScalar(1.3);
                }
                
                return projectile;
            }
            
            
            updateCombat() {
                // æ”»æ’ƒã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ›´æ–°
                if (this.attackCooldown > 0) {
                    this.attackCooldown = Math.max(0, this.attackCooldown - 16);
                }
                
                // é­”æ³•å¼¾ã®æ›´æ–°
                this.updateMagicProjectiles();
                
                // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°
                this.updateHitEffects();
            }
            
            updateMagicProjectiles() {
                for (let i = this.magicProjectiles.length - 1; i >= 0; i--) {
                    const projectile = this.magicProjectiles[i];
                    const userData = projectile.userData;
                    
                    // é­”æ³•å¼¾ã‚’ç§»å‹•
                    projectile.position.add(userData.direction.clone().multiplyScalar(userData.speed));
                    
                    // é­”æ³•å¼¾ã®å›è»¢ã¨ãƒ‘ãƒ«ã‚¹åŠ¹æœ
                    projectile.rotation.x += 0.1;
                    projectile.rotation.y += 0.1;
                    const scale = 1 + Math.sin(Date.now() * 0.01) * 0.2;
                    projectile.scale.setScalar(scale);
                    
                    // æ•µã¨ã®è¡çªåˆ¤å®š
                    let hit = false;
                    for (const enemy of this.enemies) {
                        if (!enemy.userData.alive) continue;
                        
                        const distance = projectile.position.distanceTo(enemy.position);
                        if (distance < 1.0) {
                            this.damageEnemy(enemy, userData.damage, 'magic', userData.isCritical);
                            this.createMagicHitEffect(projectile.position, userData.isCritical);
                            hit = true;
                            break;
                        }
                    }
                    
                    // å£ã¨ã®è¡çªåˆ¤å®š
                    if (!hit && this.isBlocked(projectile.position, 0.2, this.cellSize)) {
                        this.createMagicHitEffect(projectile.position);
                        hit = true;
                    }
                    
                    // å¯¿å‘½ãƒã‚§ãƒƒã‚¯
                    userData.life--;
                    if (hit || userData.life <= 0) {
                        this.scene.remove(projectile);
                        this.magicProjectiles.splice(i, 1);
                    }
                }
            }
            
            damageEnemy(enemy, damage, attackType, isCritical = false) {
                enemy.userData.hp -= damage;
                
                // æ•µãŒè¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸæ™‚ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                this.createDamageReaction(enemy, attackType);
                
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«åˆ¤å®šä»˜ãï¼‰
                this.showDamageEffect(enemy.position, damage, isCritical);
                
                if (enemy.userData.hp <= 0) {
                    this.defeatEnemy(enemy);
                }
            }
            
            createDamageReaction(enemy, attackType) {
                // æ•µã‚’å¾Œã‚ã«æŠ¼ã—å‡ºã™
                const pushDirection = new THREE.Vector3()
                    .subVectors(enemy.position, this.camera.position)
                    .normalize()
                    .multiplyScalar(0.5);
                
                const newPosition = enemy.position.clone().add(pushDirection);
                if (this.isSafePosition(newPosition, 0.8, this.cellSize)) {
                    enemy.position.copy(newPosition);
                }
                
                // æ•µã®è‰²ã‚’ä¸€ç¬å¤‰ãˆã‚‹ï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸è¡¨ç¾ï¼‰
                const originalMaterial = enemy.children[0].material;
                const damageMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    wireframe: true 
                });
                
                enemy.children[0].material = damageMaterial;
                setTimeout(() => {
                    enemy.children[0].material = originalMaterial;
                }, 200);
                
                // æ•µã®æŒ¯å‹•åŠ¹æœ
                const originalY = enemy.position.y;
                enemy.userData.shaking = true;
                setTimeout(() => {
                    enemy.userData.shaking = false;
                    enemy.position.y = originalY;
                }, 300);
            }
            
            createMagicHitEffect(position) {
                // é­”æ³•å¼¾ã®çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                const explosionCount = 15;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(explosionCount * 3);
                const colors = new Float32Array(explosionCount * 3);
                
                for (let i = 0; i < explosionCount * 3; i += 3) {
                    positions[i] = position.x + (Math.random() - 0.5) * 3;
                    positions[i + 1] = position.y + Math.random() * 3;
                    positions[i + 2] = position.z + (Math.random() - 0.5) * 3;
                    
                    colors[i] = 0; // R
                    colors[i + 1] = 1; // G
                    colors[i + 2] = 1; // B
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    blending: THREE.AdditiveBlending
                });
                
                const explosion = new THREE.Points(geometry, material);
                this.scene.add(explosion);
                this.hitEffects.push({
                    effect: explosion,
                    life: 30,
                    type: 'magic'
                });
            }
            
            updateHitEffects() {
                for (let i = this.hitEffects.length - 1; i >= 0; i--) {
                    const hitEffect = this.hitEffects[i];
                    hitEffect.life--;
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                    hitEffect.effect.material.opacity = hitEffect.life / 30;
                    
                    if (hitEffect.life <= 0) {
                        this.scene.remove(hitEffect.effect);
                        this.hitEffects.splice(i, 1);
                    }
                }
            }
            
            updateEnemies() {
                const currentTime = Date.now();
                const playerPos = this.camera.position;
                
                for (const enemy of this.enemies) {
                    if (!enemy.userData.alive) continue;
                    
                    const distance = playerPos.distanceTo(enemy.position);
                    
                    // æ•µã®æ”¹è‰¯ã•ã‚ŒãŸè¿·è·¯å†…ç§»å‹•AI
                    if (distance < 12) { // æ¤œçŸ¥ç¯„å›²ã‚’æ‹¡å¤§
                        if (distance > 2.5) {
                            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã£ã¦ç§»å‹•ï¼ˆè¿·è·¯ã‚’è€ƒæ…®ã—ãŸçµŒè·¯æ¢ç´¢ï¼‰
                            const bestMove = this.findBestEnemyMove(enemy, playerPos);
                            
                            if (bestMove) {
                                const speedMultiplier = Math.max(0.5, (10 - distance) / 10);
                                const moveSpeed = enemy.userData.speed * speedMultiplier;
                                
                                const newPosition = enemy.position.clone()
                                    .add(bestMove.multiplyScalar(moveSpeed));
                                
                                if (this.isSafePosition(newPosition, 0.8, this.cellSize)) {
                                    enemy.position.copy(newPosition);
                                }
                            }
                        } else {
                            // è¿‘è·é›¢ã§ã¯è¿·è·¯å†…ã§æˆ¦è¡“çš„ã«ç§»å‹•
                            const tacticalMove = this.findTacticalMove(enemy, playerPos, currentTime);
                            if (tacticalMove && this.isSafePosition(tacticalMove, 0.8, this.cellSize)) {
                                enemy.position.copy(tacticalMove);
                            }
                        }
                        
                        // æ”»æ’ƒåˆ¤å®š
                        if (distance < 2.5 && currentTime - enemy.userData.lastAttackTime > enemy.userData.attackCooldown) {
                            this.enemyAttack(enemy);
                            enemy.userData.lastAttackTime = currentTime;
                        }
                        
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ–¹ã‚’å‘ã
                        enemy.lookAt(playerPos);
                        
                    } else {
                        // å¾…æ©ŸçŠ¶æ…‹ï¼šè¿·è·¯å†…ã‚’ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«
                        this.enemyPatrol(enemy, currentTime);
                    }
                    
                    // æ•µã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    const baseY = 1;
                    const timeOffset = enemy.position.x + enemy.position.z;
                    
                    if (enemy.userData.shaking) {
                        // ãƒ€ãƒ¡ãƒ¼ã‚¸æ™‚ã®æŒ¯å‹•
                        enemy.position.y = baseY + Math.sin(currentTime * 0.1) * 0.1 + Math.random() * 0.1;
                    } else {
                        // é€šå¸¸ã®æµ®éŠåŠ¹æœ
                        enemy.position.y = baseY + Math.sin(currentTime * 0.003 + timeOffset) * 0.3;
                    }
                    
                    // å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    enemy.rotation.y += 0.02;
                    
                    // è§¦æ‰‹ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    for (let i = 1; i < enemy.children.length; i++) {
                        const tentacle = enemy.children[i];
                        tentacle.rotation.z = Math.sin(currentTime * 0.01 + i) * 0.3;
                    }
                }
            }
            
            findBestEnemyMove(enemy, playerPos) {
                // æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã†ãŸã‚ã®æœ€é©ãªæ–¹å‘ã‚’è¦‹ã¤ã‘ã‚‹
                const directions = [
                    new THREE.Vector3(1, 0, 0),   // å³
                    new THREE.Vector3(-1, 0, 0),  // å·¦
                    new THREE.Vector3(0, 0, 1),   // å‰
                    new THREE.Vector3(0, 0, -1)   // å¾Œ
                ];
                
                let bestDirection = null;
                let bestScore = -Infinity;
                
                for (const direction of directions) {
                    const testPos = enemy.position.clone().add(direction.clone().multiplyScalar(0.5));
                    
                    // ç§»å‹•å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                    if (this.isSafePosition(testPos, 0.8, this.cellSize)) {
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿‘ã¥ãæ–¹å‘ã‚’è©•ä¾¡
                        const distanceAfterMove = testPos.distanceTo(playerPos);
                        const currentDistance = enemy.position.distanceTo(playerPos);
                        const score = currentDistance - distanceAfterMove; // è·é›¢ãŒçŸ­ããªã‚‹ã»ã©é«˜ã‚¹ã‚³ã‚¢
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestDirection = direction;
                        }
                    }
                }
                
                return bestDirection;
            }
            
            findTacticalMove(enemy, playerPos, currentTime) {
                // è¿‘è·é›¢ã§ã®æˆ¦è¡“çš„ç§»å‹•ï¼ˆè¿·è·¯å†…ã§å††ã‚’æãã‚ˆã†ã«ç§»å‹•ï¼‰
                const angle = currentTime * 0.005 + enemy.position.x;
                const circleRadius = 2;
                const circleX = playerPos.x + Math.cos(angle) * circleRadius;
                const circleZ = playerPos.z + Math.sin(angle) * circleRadius;
                
                const circlePosition = new THREE.Vector3(circleX, enemy.position.y, circleZ);
                
                // å††é‹å‹•ãŒä¸å¯èƒ½ãªå ´åˆã¯ã€å·¦å³ã«ç§»å‹•
                if (!this.isSafePosition(circlePosition, 0.8, this.cellSize)) {
                    const playerDirection = new THREE.Vector3()
                        .subVectors(playerPos, enemy.position)
                        .normalize();
                    
                    const sideDirection = new THREE.Vector3(-playerDirection.z, 0, playerDirection.x);
                    const sidePosition = enemy.position.clone()
                        .add(sideDirection.multiplyScalar(0.5));
                    
                    if (this.isSafePosition(sidePosition, 0.8, this.cellSize)) {
                        return sidePosition;
                    }
                    
                    // åå¯¾å´ã‚‚è©¦ã™
                    const oppositeSidePosition = enemy.position.clone()
                        .add(sideDirection.multiplyScalar(-0.5));
                    
                    if (this.isSafePosition(oppositeSidePosition, 0.8, this.cellSize)) {
                        return oppositeSidePosition;
                    }
                }
                
                return circlePosition;
            }
            
            enemyPatrol(enemy, currentTime) {
                // æ•µã®ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«è¡Œå‹•ï¼ˆè¿·è·¯å†…ã‚’æ­©ãå›ã‚‹ï¼‰
                if (!enemy.userData.patrolTarget || Math.random() < 0.02) {
                    // æ–°ã—ã„ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ç›®æ¨™ã‚’è¨­å®š
                    const directions = [
                        new THREE.Vector3(2, 0, 0),
                        new THREE.Vector3(-2, 0, 0),
                        new THREE.Vector3(0, 0, 2),
                        new THREE.Vector3(0, 0, -2)
                    ];
                    
                    const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                    const targetPos = enemy.position.clone().add(randomDirection);
                    
                    if (this.isSafePosition(targetPos, 0.8, this.cellSize)) {
                        enemy.userData.patrolTarget = targetPos;
                    }
                }
                
                // ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ç›®æ¨™ã«å‘ã‹ã£ã¦ç§»å‹•
                if (enemy.userData.patrolTarget) {
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.userData.patrolTarget, enemy.position)
                        .normalize();
                    
                    const moveSpeed = enemy.userData.speed * 0.3; // ã‚†ã£ãã‚Šç§»å‹•
                    const newPosition = enemy.position.clone()
                        .add(direction.multiplyScalar(moveSpeed));
                    
                    if (this.isSafePosition(newPosition, 0.8, this.cellSize)) {
                        enemy.position.copy(newPosition);
                        
                        // ç›®æ¨™ã«åˆ°é”ã—ãŸã‚‰ã‚¯ãƒªã‚¢
                        if (enemy.position.distanceTo(enemy.userData.patrolTarget) < 1) {
                            enemy.userData.patrolTarget = null;
                        }
                    } else {
                        // ç§»å‹•ã§ããªã„å ´åˆã¯ç›®æ¨™ã‚’ã‚¯ãƒªã‚¢
                        enemy.userData.patrolTarget = null;
                    }
                }
            }
            
            enemyAttack(enemy) {
                const damage = enemy.userData.damage;
                this.takeDamage(damage);
                
                // æ”»æ’ƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                this.showAttackEffect(enemy.position);
            }
            
            takeDamage(damage) {
                const currentTime = Date.now();
                if (currentTime - this.lastDamageTime < 1000) return; // ç„¡æ•µæ™‚é–“
                
                this.lastDamageTime = currentTime;
                this.playerHP = Math.max(0, this.playerHP - damage);
                
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆç”»é¢ã‚’èµ¤ãå…‰ã‚‰ã›ã‚‹ï¼‰
                this.showPlayerDamageEffect();
                
                if (this.playerHP <= 0) {
                    this.gameOver();
                }
            }
            
            defeatEnemy(enemy) {
                enemy.userData.alive = false;
                
                // çµŒé¨“å€¤ã¨ã‚¹ã‚³ã‚¢ã‚’ç²å¾—
                const expGain = 15 + this.currentLevel * 5;
                const scoreGain = 100 + this.currentLevel * 20;
                
                this.gainExperience(expGain);
                this.addScore(scoreGain);
                
                // ã‚³ãƒ³ãƒœæ›´æ–°
                this.combo++;
                this.comboTime = Date.now();
                
                // æ•µã‚’å€’ã—ãŸã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                this.showDefeatEffect(enemy.position, expGain, scoreGain);
                
                // æ•µã‚’å‰Šé™¤
                this.scene.remove(enemy);
                const index = this.enemies.indexOf(enemy);
                if (index > -1) {
                    this.enemies.splice(index, 1);
                }
            }
            
            gainExperience(amount) {
                this.experience += amount;
                
                // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯
                while (this.experience >= this.experienceToNext) {
                    this.experience -= this.experienceToNext;
                    this.playerLevel++;
                    
                    // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—å ±é…¬
                    this.maxHP += 10;
                    this.playerHP = this.maxHP; // HPã‚’å…¨å›å¾©
                    this.magicPower += 5;
                    this.criticalChance += 0.02;
                    
                    this.experienceToNext = Math.floor(this.experienceToNext * 1.2);
                    
                    this.showLevelUpEffect();
                }
            }
            
            addScore(amount) {
                const comboBonus = this.combo > 1 ? Math.floor(amount * (this.combo * 0.1)) : 0;
                this.score += amount + comboBonus;
            }
            
            showLevelUpEffect() {
                console.log(`ğŸ‰ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—! Lv.${this.playerLevel} ğŸ‰`);
                
                // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                const particleCount = 30;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    const angle = (i / 3) * (Math.PI * 2 / particleCount);
                    positions[i] = this.camera.position.x + Math.cos(angle) * 2;
                    positions[i + 1] = this.camera.position.y + Math.random() * 3;
                    positions[i + 2] = this.camera.position.z + Math.sin(angle) * 2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: 0xffd700,
                    size: 0.3,
                    transparent: true,
                    opacity: 1.0
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                
                setTimeout(() => {
                    this.scene.remove(particles);
                }, 2000);
            }
            
            showDamageEffect(position, damage, isCritical = false) {
                // ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å€¤ã‚’è¡¨ç¤ºï¼ˆç°¡å˜ãªå®Ÿè£…ï¼‰
                const message = isCritical ? `ğŸ”¥ ${damage} ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«!` : `${damage} ãƒ€ãƒ¡ãƒ¼ã‚¸!`;
                console.log(message);
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                const particleCount = isCritical ? 20 : 10;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = position.x + (Math.random() - 0.5) * 2;
                    positions[i + 1] = position.y + Math.random() * 2;
                    positions[i + 2] = position.z + (Math.random() - 0.5) * 2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({
                    color: isCritical ? 0xffd700 : 0xff0000,
                    size: isCritical ? 0.3 : 0.2,
                    transparent: true,
                    opacity: 1.0
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                
                setTimeout(() => {
                    this.scene.remove(particles);
                }, isCritical ? 1500 : 1000);
            }
            
            showAttackEffect(position) {
                console.log('æ•µã®æ”»æ’ƒ!');
            }
            
            showPlayerDamageEffect() {
                // ç”»é¢ã‚’ä¸€ç¬èµ¤ãã™ã‚‹åŠ¹æœ
                document.body.style.background = 'rgba(255,0,0,0.3)';
                setTimeout(() => {
                    document.body.style.background = '';
                }, 200);
            }
            
            showDefeatEffect(position) {
                console.log('æ•µã‚’å€’ã—ãŸ!');
            }
            
            gameOver() {
                this.gameStarted = false;
                document.exitPointerLock();
                
                const gameOverDiv = document.createElement('div');
                gameOverDiv.innerHTML = `
                    <div style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: linear-gradient(135deg, #ff0000, #aa0000);
                        color: white;
                        padding: 40px;
                        border-radius: 20px;
                        text-align: center;
                        font-size: 2rem;
                        font-weight: bold;
                        z-index: 1000;
                    ">
                        ğŸ’€ GAME OVER ğŸ’€<br>
                        <div style="font-size: 1.2rem; margin-top: 20px;">
                            æ·±æµ·ã®é­”ç‰©ã«å€’ã•ã‚ŒãŸ...<br>
                            ç«  ${this.currentLevel} ã§åŠ›å°½ããŸ
                        </div>
                        <button onclick="location.reload()" style="
                            background: #ffffff;
                            color: #ff0000;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 25px;
                            font-size: 1.1rem;
                            cursor: pointer;
                            margin-top: 25px;
                        ">
                            æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã™
                        </button>
                    </div>
                `;
                document.body.appendChild(gameOverDiv);
            }
            
            gameWin() {
                const endTime = Date.now();
                const totalTime = Math.floor((endTime - this.startTime) / 1000);
                
                this.gameStarted = false;
                document.exitPointerLock();
                
                // æ´¾æ‰‹ãªãŠç¥ã„æ¼”å‡ºã‚’é–‹å§‹
                this.startCelebration(totalTime);
            }
            
            startCelebration(totalTime) {
                // ç¥ç¦ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å¤§é‡ç”Ÿæˆ
                this.createCelebrationParticles();
                
                // å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                this.showVictoryMessage(totalTime);
                
                // ã‚«ãƒ¡ãƒ©ã‚’è‡ªå‹•å›è»¢
                this.celebrationRotation = 0;
                this.isCelebrating = true;
                this.levelCompleted = true;
                
                // 5ç§’å¾Œã«ãƒªã‚»ãƒƒãƒˆ
                setTimeout(() => {
                    this.endCelebration();
                }, 5000);
            }
            
            showStoryIntro() {
                const story = this.storyMessages[this.currentLevel];
                if (!story) return;
                
                // ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ç´¹ä»‹ç”»é¢ã‚’ä½œæˆ
                const storyDiv = document.createElement('div');
                storyDiv.id = 'story-intro';
                storyDiv.innerHTML = `
                    <div style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(135deg, rgba(0,20,40,0.95), rgba(0,60,100,0.95));
                        color: white;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 2000;
                        backdrop-filter: blur(10px);
                    ">
                        <div style="
                            text-align: center;
                            max-width: 600px;
                            padding: 40px;
                            background: linear-gradient(135deg, rgba(0,188,212,0.2), rgba(77,208,225,0.2));
                            border-radius: 20px;
                            border: 2px solid rgba(77,208,225,0.5);
                            animation: storyFadeIn 1s ease-out;
                        ">
                            <h2 style="font-size: 2.5rem; margin-bottom: 30px; color: #4dd0e1;">
                                ${story.title}
                            </h2>
                            <p style="font-size: 1.3rem; line-height: 1.6; margin-bottom: 30px; white-space: pre-line;">
                                ${story.intro}
                            </p>
                            <div style="font-size: 1rem; opacity: 0.8; margin-bottom: 30px;">
                                ãƒ¬ãƒ™ãƒ« ${this.currentLevel} / ${this.maxLevel}
                            </div>
                            <button id="story-continue" style="
                                background: linear-gradient(135deg, #00bcd4, #4dd0e1);
                                color: white;
                                border: none;
                                padding: 15px 30px;
                                border-radius: 25px;
                                font-size: 1.1rem;
                                cursor: pointer;
                                transition: all 0.3s ease;
                            ">
                                å†’é™ºã‚’å§‹ã‚ã‚‹
                            </button>
                        </div>
                    </div>
                `;
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨CSS
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes storyFadeIn {
                        0% { opacity: 0; transform: translateY(30px); }
                        100% { opacity: 1; transform: translateY(0); }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(storyDiv);
                
                // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§é–‹å§‹
                document.getElementById('story-continue').addEventListener('click', () => {
                    storyDiv.remove();
                    this.actuallyStartGame();
                });
            }
            
            createCelebrationParticles() {
                // èŠ±ç«ã®ã‚ˆã†ãªçˆ†ç™ºãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                const particleCount = 500;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const velocities = [];
                
                const goalPos = this.goal.position;
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // ã‚´ãƒ¼ãƒ«ä½ç½®ã‹ã‚‰æ”¾å°„çŠ¶ã«
                    positions[i3] = goalPos.x;
                    positions[i3 + 1] = goalPos.y;
                    positions[i3 + 2] = goalPos.z;
                    
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªè‰²ï¼ˆé‡‘ã€é’ã€èµ¤ã€ç·‘ï¼‰
                    const colorChoice = Math.random();
                    if (colorChoice < 0.25) {
                        colors[i3] = 1; colors[i3 + 1] = 0.8; colors[i3 + 2] = 0; // é‡‘
                    } else if (colorChoice < 0.5) {
                        colors[i3] = 0; colors[i3 + 1] = 0.5; colors[i3 + 2] = 1; // é’
                    } else if (colorChoice < 0.75) {
                        colors[i3] = 1; colors[i3 + 1] = 0; colors[i3 + 2] = 0; // èµ¤
                    } else {
                        colors[i3] = 0; colors[i3 + 1] = 1; colors[i3 + 2] = 0; // ç·‘
                    }
                    
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
                    velocities.push({
                        x: (Math.random() - 0.5) * 10,
                        y: Math.random() * 15 + 5,
                        z: (Math.random() - 0.5) * 10
                    });
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                this.celebrationParticles = new THREE.Points(geometry, material);
                this.celebrationVelocities = velocities;
                this.scene.add(this.celebrationParticles);
            }
            
            showVictoryMessage(totalTime) {
                const story = this.storyMessages[this.currentLevel];
                const isLastLevel = this.currentLevel >= this.maxLevel;
                
                // HTMLè¦ç´ ã§å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                const victoryDiv = document.createElement('div');
                victoryDiv.id = 'victory-message';
                victoryDiv.innerHTML = `
                    <div style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
                        color: white;
                        padding: 40px;
                        border-radius: 20px;
                        text-align: center;
                        font-size: 2rem;
                        font-weight: bold;
                        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                        z-index: 1000;
                        animation: victoryPulse 2s ease-in-out infinite;
                        max-width: 600px;
                    ">
                        ğŸ‰ ãƒ¬ãƒ™ãƒ« ${this.currentLevel} ã‚¯ãƒªã‚¢! ğŸ‰<br>
                        <div style="font-size: 1.3rem; margin-top: 20px;">
                            ã‚¿ã‚¤ãƒ : ${totalTime}ç§’
                        </div>
                        <div style="font-size: 1rem; margin-top: 20px; line-height: 1.4; white-space: pre-line; opacity: 0.95;">
                            ${story.complete}
                        </div>
                        ${!isLastLevel ? `
                        <button id="next-level-btn" style="
                            background: linear-gradient(135deg, #feca57, #ff9f43);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 25px;
                            font-size: 1.1rem;
                            cursor: pointer;
                            margin-top: 25px;
                            transition: all 0.3s ease;
                        ">
                            æ¬¡ã®ç« ã¸é€²ã‚€ â¤
                        </button>
                        ` : `
                        <div style="font-size: 1.2rem; margin-top: 25px; color: #feca57;">
                            ğŸ† å…¨ã¦ã®ç« ã‚’ã‚¯ãƒªã‚¢ï¼å›ã¯çœŸã®æµ·å­¦ãƒã‚¹ã‚¿ãƒ¼ã ï¼ ğŸ†
                        </div>
                        <div style="
                            background: linear-gradient(135deg, #ff6b9d, #feca57);
                            color: white;
                            padding: 20px;
                            border-radius: 15px;
                            margin-top: 20px;
                            font-size: 1.1rem;
                            font-weight: bold;
                            text-align: center;
                            box-shadow: 0 8px 25px rgba(255, 107, 157, 0.4);
                        ">
                            ğŸ ç‰¹åˆ¥å ±é…¬ç²å¾—ï¼ ğŸ<br>
                            <span style="font-size: 1.3rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                                2ãƒ“ãƒ¼ãƒãƒ€ã‚¤ãƒ“ãƒ³ã‚° 5% OFF
                            </span>
                        </div>
                        <button id="discount-form-btn" style="
                            background: linear-gradient(135deg, #ff6b9d, #ff9f43);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 25px;
                            font-size: 1.1rem;
                            cursor: pointer;
                            margin-top: 15px;
                            margin-right: 10px;
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.3);
                        ">
                            ğŸŒŠ 5%å‰²å¼•ã‚’ç”³ã—è¾¼ã‚€
                        </button>
                        <button id="restart-game-btn" style="
                            background: linear-gradient(135deg, #26c6da, #00bcd4);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 25px;
                            font-size: 1.1rem;
                            cursor: pointer;
                            margin-top: 15px;
                            transition: all 0.3s ease;
                        ">
                            å†åº¦å†’é™ºã™ã‚‹
                        </button>
                        `}
                    </div>
                `;
                
                // CSSã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes victoryPulse {
                        0%, 100% { transform: translate(-50%, -50%) scale(1); }
                        50% { transform: translate(-50%, -50%) scale(1.05); }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(victoryDiv);
                
                // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
                if (!isLastLevel) {
                    const nextBtn = document.getElementById('next-level-btn');
                    if (nextBtn) {
                        nextBtn.addEventListener('click', () => {
                            this.nextLevel();
                        });
                    }
                } else {
                    // 10ç« ã‚¯ãƒªã‚¢æ™‚ã®ç‰¹åˆ¥ãƒ•ã‚©ãƒ¼ãƒ 
                    const discountBtn = document.getElementById('discount-form-btn');
                    if (discountBtn) {
                        discountBtn.addEventListener('click', () => {
                            this.showDiscountForm();
                        });
                    }
                    
                    const restartBtn = document.getElementById('restart-game-btn');
                    if (restartBtn) {
                        restartBtn.addEventListener('click', () => {
                            this.restartGame();
                        });
                    }
                }
            }
            
            nextLevel() {
                this.currentLevel++;
                this.playerHP = Math.min(this.maxHP, this.playerHP + 30); // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã§HPå›å¾©
                this.remainingTime = this.timeLimit; // æ™‚é–“ãƒªã‚»ãƒƒãƒˆ
                this.isGameOver = false;
                this.endCelebration();
                this.resetPlayerPosition();
                this.clearMaze();
                this.generateComplexMaze();
                this.createMaze3D();
                this.initMinimap(); // ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.updateHUD();
                
                // ã‚²ãƒ¼ãƒ ã‚’ä¸€æ™‚åœæ­¢ï¼ˆã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã‚‹ãŸã‚ï¼‰
                this.gameStarted = false;
            }
            
            restartGame() {
                this.currentLevel = 1;
                this.playerHP = this.maxHP; // HPå®Œå…¨å›å¾©
                this.remainingTime = this.timeLimit; // æ™‚é–“ãƒªã‚»ãƒƒãƒˆ
                this.isGameOver = false;
                this.endCelebration();
                this.resetPlayerPosition();
                this.clearMaze();
                this.generateComplexMaze();
                this.createMaze3D();
                this.initMinimap(); // ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.updateHUD();
                
                // ã‚²ãƒ¼ãƒ ã‚’ä¸€æ™‚åœæ­¢ï¼ˆã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã‚‹ãŸã‚ï¼‰
                this.gameStarted = false;
            }
            
            resetPlayerPosition() {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¹ã‚¿ãƒ¼ãƒˆä½ç½®ã«æˆ»ã™
                this.camera.position.set(6, 2, 6);
                this.camera.rotation.set(0, 0, 0);
                this.rotationX = 0;
                this.rotationY = 0;
            }
            
            clearMaze() {
                // æ—¢å­˜ã®è¿·è·¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤
                const objectsToRemove = [];
                this.scene.traverse((child) => {
                    if (child.type === 'LineSegments' && child !== this.particles) {
                        objectsToRemove.push(child);
                    }
                });
                
                objectsToRemove.forEach(obj => {
                    this.scene.remove(obj);
                });
                
                // ã‚´ãƒ¼ãƒ«ã‚‚å‰Šé™¤
                if (this.goal) {
                    this.scene.remove(this.goal);
                    this.goal = null;
                }
                
                // æ•µã‚‚å‰Šé™¤
                this.enemies.forEach(enemy => {
                    this.scene.remove(enemy);
                });
                this.enemies = [];
                
                // é­”æ³•å¼¾ã‚‚å‰Šé™¤
                this.magicProjectiles.forEach(projectile => {
                    this.scene.remove(projectile);
                });
                this.magicProjectiles = [];
                
                // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚‚å‰Šé™¤
                this.hitEffects.forEach(effect => {
                    this.scene.remove(effect.effect);
                });
                this.hitEffects = [];
            }
            
            endCelebration() {
                this.isCelebrating = false;
                this.levelCompleted = false;
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
                if (this.celebrationParticles) {
                    this.scene.remove(this.celebrationParticles);
                    this.celebrationParticles = null;
                }
                
                // å‹åˆ©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤
                const victoryMsg = document.getElementById('victory-message');
                if (victoryMsg) {
                    victoryMsg.remove();
                }
                
                // ä»–ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚‚å‰Šé™¤
                const storyIntro = document.getElementById('story-intro');
                if (storyIntro) {
                    storyIntro.remove();
                }
                
            }
            
            actuallyStartGame() {
                console.log('Actually starting game...');
                this.gameStarted = true;
                this.startTime = Date.now();
                this.remainingTime = this.timeLimit; // ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
                this.isGameOver = false;
                
                // ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ»ãƒ•ãƒƒã‚¿ãƒ¼ãƒ»ã‚¿ã‚¤ãƒˆãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’éè¡¨ç¤º
                document.getElementById('gameHeader').classList.add('game-started');
                document.getElementById('gameFooter').classList.add('game-started');
                document.getElementById('gameTitleOverlay').classList.add('game-started');
                
                // ã‚²ãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’è¡¨ç¤º
                const gameControls = document.getElementById('gameControls');
                if (gameControls) {
                    gameControls.style.display = 'flex';
                }
                
                const canvas = document.getElementById('canvas');
                console.log('Requesting pointer lock...');
                canvas.requestPointerLock().then(() => {
                    console.log('Pointer lock request successful');
                }).catch((err) => {
                    console.error('Pointer lock request failed:', err);
                });
                
                console.log('Game actually started');
            }
            
            updateTimer() {
                if (!this.gameStarted || !this.startTime || this.isGameOver) return;
                
                const currentTime = Date.now();
                const elapsedSeconds = Math.floor((currentTime - this.startTime) / 1000);
                
                this.remainingTime = Math.max(0, this.timeLimit - elapsedSeconds);
                
                const minutes = Math.floor(this.remainingTime / 60);
                const seconds = this.remainingTime % 60;
                const timeDisplay = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                document.getElementById('remainingTime').textContent = timeDisplay;
                
                // æ™‚é–“è­¦å‘Šè¡¨ç¤º
                const timeWarning = document.getElementById('timeWarning');
                if (this.remainingTime <= 30 && this.remainingTime > 0) {
                    timeWarning.style.display = 'block';
                } else {
                    timeWarning.style.display = 'none';
                }
                
                // ã‚¿ã‚¤ãƒ ã‚¢ãƒƒãƒ—
                if (this.remainingTime <= 0) {
                    this.gameOver('æ™‚é–“åˆ‡ã‚Œ');
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updateMovement();
                this.updateTimer();
                this.updateCombat();
                this.updateEnemies();
                this.updateCompass();
                this.updateMinimap();
                
                // ã‚´ãƒ¼ãƒ«ã®å›è»¢ï¼ˆãŠç¥ã„ä¸­ã¯ã‚ˆã‚Šæ¿€ã—ãï¼‰
                if (this.goal) {
                    this.goal.rotation.y += this.isCelebrating ? 0.05 : 0.01;
                }
                
                // ãŠç¥ã„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.isCelebrating && this.celebrationParticles) {
                    this.updateCelebrationParticles();
                    
                    // ã‚«ãƒ¡ãƒ©ã®è‡ªå‹•å›è»¢
                    this.celebrationRotation += 0.02;
                    const radius = 8;
                    const goalPos = this.goal.position;
                    this.camera.position.x = goalPos.x + Math.cos(this.celebrationRotation) * radius;
                    this.camera.position.z = goalPos.z + Math.sin(this.celebrationRotation) * radius;
                    this.camera.lookAt(goalPos);
                }
                
                // æµ·ä¸­ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.particles) {
                    this.particles.rotation.y += 0.002;
                    const positions = this.particles.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] += 0.01; // ã‚†ã£ãã‚Šä¸Šæ˜‡
                        if (positions[i] > 20) {
                            positions[i] = 0; // ä¸Šã¾ã§è¡Œã£ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
                        }
                    }
                    this.particles.geometry.attributes.position.needsUpdate = true;
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            updateCelebrationParticles() {
                const positions = this.celebrationParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < this.celebrationVelocities.length; i++) {
                    const i3 = i * 3;
                    const velocity = this.celebrationVelocities[i];
                    
                    // ä½ç½®ã‚’æ›´æ–°
                    positions[i3] += velocity.x * 0.1;
                    positions[i3 + 1] += velocity.y * 0.1;
                    positions[i3 + 2] += velocity.z * 0.1;
                    
                    // é‡åŠ›åŠ¹æœ
                    velocity.y -= 0.5;
                    
                    // ç©ºæ°—æŠµæŠ—
                    velocity.x *= 0.98;
                    velocity.z *= 0.98;
                }
                
                this.celebrationParticles.geometry.attributes.position.needsUpdate = true;
            }
            
            showDiscountForm() {
                // ç”³ã—è¾¼ã¿ãƒ•ã‚©ãƒ¼ãƒ ã‚’ä½œæˆ
                const formDiv = document.createElement('div');
                formDiv.id = 'discount-form';
                formDiv.innerHTML = `
                    <div style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 10000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">
                        <div style="
                            background: linear-gradient(135deg, #ffffff 0%, #e0f7fa 100%);
                            color: #006064;
                            padding: 40px;
                            border-radius: 20px;
                            max-width: 500px;
                            width: 90%;
                            box-shadow: 0 20px 60px rgba(0, 188, 212, 0.4);
                            border: 3px solid #00bcd4;
                            text-align: center;
                        ">
                            <h2 style="
                                color: #00bcd4;
                                font-size: 2rem;
                                margin-bottom: 20px;
                                text-shadow: 2px 2px 4px rgba(0, 188, 212, 0.2);
                            ">
                                ğŸŒŠ 2ãƒ“ãƒ¼ãƒãƒ€ã‚¤ãƒ“ãƒ³ã‚° 5%OFF ğŸŒŠ
                            </h2>
                            <p style="
                                font-size: 1.1rem;
                                margin-bottom: 25px;
                                line-height: 1.5;
                            ">
                                æµ·å­¦ãƒã‚¹ã‚¿ãƒ¼ã®ç§°å·ã‚’ç²å¾—ã—ãŸã‚ãªãŸã«<br>
                                ç‰¹åˆ¥å‰²å¼•ã‚’ã”ç”¨æ„ã„ãŸã—ã¾ã—ãŸï¼
                            </p>
                            
                            <form action="mailto:info@miura-diving.com" method="post" enctype="text/plain" id="diving-discount-form" style="text-align: left;">
                                <div style="margin-bottom: 15px;">
                                    <label style="font-weight: bold; display: block; margin-bottom: 5px;">ãŠåå‰ *</label>
                                    <input type="text" name="name" required style="
                                        width: 100%;
                                        padding: 10px;
                                        border: 2px solid #00bcd4;
                                        border-radius: 8px;
                                        font-size: 1rem;
                                        box-sizing: border-box;
                                    ">
                                </div>
                                
                                <div style="margin-bottom: 15px;">
                                    <label style="font-weight: bold; display: block; margin-bottom: 5px;">ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ *</label>
                                    <input type="email" name="email" required style="
                                        width: 100%;
                                        padding: 10px;
                                        border: 2px solid #00bcd4;
                                        border-radius: 8px;
                                        font-size: 1rem;
                                        box-sizing: border-box;
                                    ">
                                </div>
                                
                                <div style="margin-bottom: 15px;">
                                    <label style="font-weight: bold; display: block; margin-bottom: 5px;">é›»è©±ç•ªå·</label>
                                    <input type="tel" name="phone" style="
                                        width: 100%;
                                        padding: 10px;
                                        border: 2px solid #00bcd4;
                                        border-radius: 8px;
                                        font-size: 1rem;
                                        box-sizing: border-box;
                                    ">
                                </div>
                                
                                <div style="margin-bottom: 20px;">
                                    <label style="font-weight: bold; display: block; margin-bottom: 5px;">å¸Œæœ›æ—¥ç¨‹ãƒ»ãã®ä»–</label>
                                    <textarea name="message" rows="3" style="
                                        width: 100%;
                                        padding: 10px;
                                        border: 2px solid #00bcd4;
                                        border-radius: 8px;
                                        font-size: 1rem;
                                        box-sizing: border-box;
                                        resize: vertical;
                                    " placeholder="ã”å¸Œæœ›ã®æ—¥ç¨‹ã‚„ã”è³ªå•ãŒã‚ã‚Œã°ãŠæ›¸ããã ã•ã„"></textarea>
                                </div>
                                
                                <div style="text-align: center;">
                                    <button type="submit" style="
                                        background: linear-gradient(135deg, #ff6b9d, #ff9f43);
                                        color: white;
                                        border: none;
                                        padding: 15px 30px;
                                        border-radius: 25px;
                                        font-size: 1.1rem;
                                        cursor: pointer;
                                        margin-right: 10px;
                                        transition: all 0.3s ease;
                                        box-shadow: 0 4px 15px rgba(255, 107, 157, 0.3);
                                    ">
                                        ğŸŒŠ ç”³ã—è¾¼ã‚€
                                    </button>
                                    <button type="button" id="close-form-btn" style="
                                        background: #666;
                                        color: white;
                                        border: none;
                                        padding: 15px 30px;
                                        border-radius: 25px;
                                        font-size: 1.1rem;
                                        cursor: pointer;
                                        transition: all 0.3s ease;
                                    ">
                                        é–‰ã˜ã‚‹
                                    </button>
                                </div>
                            </form>
                            
                            <div style="
                                margin-top: 20px;
                                font-size: 0.9rem;
                                color: #666;
                                line-height: 1.4;
                            ">
                                â€» å‰²å¼•ã¯åº—èˆ—ã§ã®äºˆç´„æ™‚ã«ã€Œæµ·å­¦ãƒã‚¹ã‚¿ãƒ¼å‰²å¼•ã€ã¨ãŠä¼ãˆãã ã•ã„<br>
                                â€» ä»–ã®å‰²å¼•ã¨ã®ä½µç”¨ã¯ã§ãã¾ã›ã‚“
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(formDiv);
                
                // ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡å‡¦ç†
                const form = document.getElementById('diving-discount-form');
                form.addEventListener('submit', () => {
                    setTimeout(() => {
                        alert('ç”³ã—è¾¼ã¿ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼\nãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ—ãƒªãŒé–‹ãã¾ã™ã€‚\n\né€ä¿¡å¾Œã€ä¸‰æµ¦æµ·ã®å­¦æ ¡ã‹ã‚‰ç¢ºèªã®ã”é€£çµ¡ã‚’ã„ãŸã—ã¾ã™ã€‚');
                    }, 100);
                });
                
                // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
                const closeBtn = document.getElementById('close-form-btn');
                closeBtn.addEventListener('click', () => {
                    document.body.removeChild(formDiv);
                });
            }
            
        }
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹
        let game; // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã§ã‚²ãƒ¼ãƒ ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä¿æŒ
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, creating game...');
            game = new SimpleMaze3D();
        });
    </script>
</body>
</html>